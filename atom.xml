<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MTUNIQUE&#39;S BLOG</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mtunique.com/"/>
  <updated>2017-04-10T08:22:19.000Z</updated>
  <id>http://mtunique.com/</id>
  
  <author>
    <name>Mtunique</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】用 Scala 的Parser Combinator 构建词法和语法分析器</title>
    <link href="http://mtunique.com/scala_parser_combinator/"/>
    <id>http://mtunique.com/scala_parser_combinator/</id>
    <published>2017-04-08T14:28:00.000Z</published>
    <updated>2017-04-10T08:22:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然有几个关于如何使用Parser Combinator构建简单解析器的资源，但迄今为止还没有描述如何从头开始构建完整的词法和语法分析器。</p>
<p>下面将介绍如何构建词法分析器来将文本转化成一系列token，以及构建解析器将token解析为抽象语法树（AST）。</p>
<h2 id="语言概述"><a href="#语言概述" class="headerlink" title="语言概述"></a>语言概述</h2><p>“workflow code”用来描述工作流，即 可执行的有向无环图指令。以下是有效程序的示例。 请记住，块是通过<a href="https://en.wikipedia.org/wiki/Off-side_rule" target="_blank" rel="external">缩进</a>定界的，类似于Python语言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">read input name, country</div><div class="line">switch:</div><div class="line">  country == &quot;PT&quot; -&gt;</div><div class="line">    call service &quot;A&quot;</div><div class="line">    exit</div><div class="line">  otherwise -&gt;</div><div class="line">    call service &quot;B&quot;</div><div class="line">    switch:</div><div class="line">      name == &quot;unknown&quot; -&gt;</div><div class="line">        exit</div><div class="line">      otherwise -&gt;</div><div class="line">        call service &quot;C&quot;</div><div class="line">        exit</div></pre></td></tr></table></figure>
<p>我们希望将其解析成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">AndThen(</div><div class="line">  ReadInput(List(name, country)),</div><div class="line">  Choice(List(</div><div class="line">    IfThen(</div><div class="line">      Equals(country, PT),</div><div class="line">      AndThen(CallService(A), Exit)</div><div class="line">    ),</div><div class="line">    OtherwiseThen(</div><div class="line">      AndThen(</div><div class="line">        CallService(B),</div><div class="line">        Choice(List(</div><div class="line">          IfThen(Equals(name, unknown), Exit),</div><div class="line">          OtherwiseThen(AndThen(CallService(C), Exit))</div><div class="line">        ))</div><div class="line">      )</div><div class="line">    )</div><div class="line">  ))</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>这个语法的<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form" target="_blank" rel="external">BNF</a>表示如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;block&gt; ::= (&lt;statement&gt;)+</div><div class="line"></div><div class="line">&lt;statement&gt; ::= &quot;exit&quot;</div><div class="line">              | &quot;read input&quot; (&lt;identifier&gt; &quot;,&quot;)* &lt;identifier&gt;</div><div class="line">              | &quot;call service&quot; &lt;stringLiteral&gt;</div><div class="line">              | &quot;switch&quot; &quot;:&quot; INDENT (&lt;ifThen&gt;)+ [otherwiseThen] DEDENT</div><div class="line"></div><div class="line">&lt;ifThen&gt; ::= &lt;condition&gt; &quot;-&gt;&quot; INDENT &lt;block&gt; DEDENT</div><div class="line"></div><div class="line">&lt;otherwiseThen&gt; ::= &quot;otherwise&quot; &quot;-&gt;&quot; INDENT &lt;block&gt; DEDENT</div><div class="line"></div><div class="line">&lt;condition&gt; ::= &lt;identifier&gt; &quot;==&quot; &lt;stringLiteral&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Parser-combinators"><a href="#Parser-combinators" class="headerlink" title="Parser combinators"></a>Parser combinators</h2><p><a href="https://en.wikipedia.org/wiki/Parser_combinator" target="_blank" rel="external">parser combinator</a> 是一个接受解析器作为输入并返回一个新的解析器作为输出的函数，类似于高阶函数。</p>
<p>举个例子，假设我们有一个parser <code>int</code>来识别整数字面值，一个parser<code>plus</code>来识别 ‘+’ 字符，我们可以产生一个解析器来识别 <code>int plus int</code>序列为整数加法。</p>
<p>Scala标准库包括解析器组合器的实现：<a href="https://github.com/scala/scala-parser-combinators" target="_blank" rel="external">https://github.com/scala/scala-parser-combinators</a></p>
<h2 id="构建词法分析程序"><a href="#构建词法分析程序" class="headerlink" title="构建词法分析程序"></a>构建词法分析程序</h2><p>我们将会用到的标识符和字符串字面值的token，以及所有保留字和标点符号: <code>exit</code>, <code>read input</code>, <code>call service</code>, <code>switch</code>, <code>otherwise</code>, <code>:</code>, <code>-&gt;</code>, <code>==</code>,  <code>,</code>。</p>
<p>我们还需要生成代表缩进增加和减少的人造token：<code>INDENT</code>和<code>DEDENT</code>。 现在请忽略这些，因为我们将在以后的阶段中进行讨论。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">WorkflowToken</span></span></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">IDENTIFIER</span>(<span class="params">str: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LITERAL</span>(<span class="params">str: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">INDENTATION</span>(<span class="params">spaces: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">EXIT</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">READINPUT</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">CALLSERVICE</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SWITCH</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">OTHERWISE</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">COLON</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">ARROW</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">EQUALS</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">COMMA</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">INDENT</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">DEDENT</span> <span class="keyword">extends</span> <span class="title">WorkflowToken</span></span></div></pre></td></tr></table></figure>
<p>我们的词法分析器继承<a href="http://www.scala-lang.org/api/rc/index.html#scala.util.parsing.combinator.RegexParsers" target="_blank" rel="external">RegexParsers</a>(一个<a href="http://www.scala-lang.org/api/rc/index.html#scala.util.parsing.combinator.Parsers" target="_blank" rel="external">Parsers</a>的子类)。 <code>RegexParsers</code>是专门用于使用<a href="https://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="external">正则表达式</a>构建字符解析器的。 它提供了从<code>String</code>和<code>Regex</code>到<code>Parser [String]</code>的隐式转换。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">WorkflowLexer</span> <span class="keyword">extends</span> <span class="title">RegexParsers</span> </span>&#123;</div></pre></td></tr></table></figure></p>
<p>我们首先指定哪些字符应该被忽略为空格。 我们不能忽略<code>\ n</code>，因为我们需要它来识别由它后面的空格数定义的标识级别。 每个其他空白字符都可以忽略。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">skipWhitespace</span> </span>= <span class="literal">true</span></div><div class="line"><span class="keyword">override</span> <span class="keyword">val</span> whiteSpace = <span class="string">"[ \t\r\f]+"</span>.r</div></pre></td></tr></table></figure>
<p>现在我们构建一个标识符的解析器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">identifier</span></span>: <span class="type">Parser</span>[<span class="type">IDENTIFIER</span>] = &#123;</div><div class="line">  <span class="string">"[a-zA-Z_][a-zA-Z0-9_]*"</span>.r ^^ &#123; str =&gt; <span class="type">IDENTIFIER</span>(str) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>^^</code>操作符用来对解析结果进行映射。 正则表达式<code>“[a-zA-Z _] [a-zA-Z0-9 _] *”.r</code>被隐式转换为Parser [String]的一个实例，映射是一个<code>(String =&gt; IDENTIFIER)</code>函数，从而返回一个<code>Parser[IDENTIFIER]</code>实例。</p>
<p>字符串字面值和标识的解析器类似：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def literal: Parser[LITERAL] = &#123;</div><div class="line">  """"[^"]*"""".r ^^ &#123; str =&gt;</div><div class="line">    val content = str.substring(1, str.length - 1)</div><div class="line">    LITERAL(content)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">def indentation: Parser[INDENTATION] = &#123;</div><div class="line">  "\n[ ]*".r ^^ &#123; whitespace =&gt;</div><div class="line">    val nSpaces = whitespace.length - 1</div><div class="line">    INDENTATION(nSpaces)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关键字的解析器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>          </span>= <span class="string">"exit"</span>          ^^ (_ =&gt; <span class="type">EXIT</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">readInput</span>     </span>= <span class="string">"read input"</span>    ^^ (_ =&gt; <span class="type">READINPUT</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callService</span>   </span>= <span class="string">"call service"</span>  ^^ (_ =&gt; <span class="type">CALLSERVICE</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch</span>        </span>= <span class="string">"switch"</span>        ^^ (_ =&gt; <span class="type">SWITCH</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">otherwise</span>     </span>= <span class="string">"otherwise"</span>     ^^ (_ =&gt; <span class="type">OTHERWISE</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">colon</span>         </span>= <span class="string">":"</span>             ^^ (_ =&gt; <span class="type">COLON</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrow</span>         </span>= <span class="string">"-&gt;"</span>            ^^ (_ =&gt; <span class="type">ARROW</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">equals</span>        </span>= <span class="string">"=="</span>            ^^ (_ =&gt; <span class="type">EQUALS</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">comma</span>         </span>= <span class="string">","</span>             ^^ (_ =&gt; <span class="type">COMMA</span>)</div></pre></td></tr></table></figure></p>
<p>现在我们将把所有这些parser组合成一个能识别每一个token的解析器。 我们将利用以下操作符：</p>
<ul>
<li><code>|</code>(or)，识别任何token解析器;</li>
<li><code>rep1</code>，识别他参数一次或多次重复</li>
<li><code>phrase</code> ，尝试消耗所有输入知道不再剩余</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokens</span></span>: <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">WorkflowToken</span>]] = &#123;</div><div class="line">  phrase(rep1(exit | readInput | callService | switch | otherwise | colon | arrow</div><div class="line">     | equals | comma | literal | identifier | indentation)) ^^ &#123; rawTokens =&gt;</div><div class="line">    processIndentations(rawTokens)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意，操作数的顺序在处理歧义时很重要。 如果我们<code>identifier</code>放在其他token前面，我们的解析器将永远不会将它们识别为特殊关键字，因为它们将被成功地解析为标识符。</p>
<h2 id="处理缩进"><a href="#处理缩进" class="headerlink" title="处理缩进"></a>处理缩进</h2><p>我们使用<code>processIndentations</code>方法对我们的解析结果进行简短的后处理步骤。 用于从<code>INDENTATION</code>token中生成人造<code>INDENT</code>和<code>DEDENT</code>token。缩进级别的每次增加都被压入栈中以产生<code>INDENT</code>，缩进级别的缩小将从缩进堆栈弹出，生成<code>DEDENT</code>。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processIndentations</span></span>(tokens: <span class="type">List</span>[<span class="type">WorkflowToken</span>],</div><div class="line">                                indents: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">0</span>)): <span class="type">List</span>[<span class="type">WorkflowToken</span>] = &#123;</div><div class="line">  tokens.headOption <span class="keyword">match</span> &#123;</div><div class="line"></div><div class="line">    <span class="comment">// if there is an increase in indentation level, we push this new level into the stack</span></div><div class="line">    <span class="comment">// and produce an INDENT</span></div><div class="line">    <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">INDENTATION</span>(spaces)) <span class="keyword">if</span> spaces &gt; indents.head =&gt;</div><div class="line">      <span class="type">INDENT</span> :: processIndentations(tokens.tail, spaces :: indents)</div><div class="line"></div><div class="line">    <span class="comment">// if there is a decrease, we pop from the stack until we have matched the new level,</span></div><div class="line">    <span class="comment">// producing a DEDENT for each pop</span></div><div class="line">    <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">INDENTATION</span>(spaces)) <span class="keyword">if</span> spaces &lt; indents.head =&gt;</div><div class="line">      <span class="keyword">val</span> (dropped, kept) = indents.partition(_ &gt; spaces)</div><div class="line">      (dropped map (_ =&gt; <span class="type">DEDENT</span>)) ::: processIndentations(tokens.tail, kept)</div><div class="line"></div><div class="line">    <span class="comment">// if the indentation level stays unchanged, no tokens are produced</span></div><div class="line">    <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">INDENTATION</span>(spaces)) <span class="keyword">if</span> spaces == indents.head =&gt;</div><div class="line">      processIndentations(tokens.tail, indents)</div><div class="line"></div><div class="line">    <span class="comment">// other tokens are ignored</span></div><div class="line">    <span class="keyword">case</span> <span class="type">Some</span>(token) =&gt;</div><div class="line">      token :: processIndentations(tokens.tail, indents)</div><div class="line"></div><div class="line">    <span class="comment">// the final step is to produce a DEDENT for each indentation level still remaining, thus</span></div><div class="line">    <span class="comment">// "closing" the remaining open INDENTS</span></div><div class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt;</div><div class="line">      indents.filter(_ &gt; <span class="number">0</span>).map(_ =&gt; <span class="type">DEDENT</span>)</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在所有的都设置好，这个token parser将把<code>Reader[Char]</code>解析成<code>ParseResult[List[WorkflowToken]]</code>。<code>RegexParsers</code>定义了自己的<code>Reader [Char]</code>，它由它提供的<code>parser</code>方法内部调用。 然后我们为<code>WorkflowLexer</code>定义一个<code>apply</code>方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">WorkflowCompilationError</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkflowLexerError</span>(<span class="params">msg: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">WorkflowCompilationError</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">WorkflowLexer</span> <span class="keyword">extends</span> <span class="title">RegexParsers</span> </span>&#123;</div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(code: <span class="type">String</span>): <span class="type">Either</span>[<span class="type">WorkflowLexerError</span>, <span class="type">List</span>[<span class="type">WorkflowToken</span>]] = &#123;</div><div class="line">    parse(tokens, code) <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">NoSuccess</span>(msg, next) =&gt; <span class="type">Left</span>(<span class="type">WorkflowLexerError</span>(msg))</div><div class="line">      <span class="keyword">case</span> <span class="type">Success</span>(result, next) =&gt; <span class="type">Right</span>(result)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>应用下样例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="type">WorkflowLexer</span>(code)</div><div class="line">res0: <span class="type">Either</span>[<span class="type">WorkflowLexerError</span>,<span class="type">List</span>[<span class="type">WorkflowToken</span>]] = <span class="type">Right</span>(<span class="type">List</span>(<span class="type">READINPUT</span>, <span class="type">IDENTIFIER</span>(name), <span class="type">COMMA</span>,</div><div class="line"><span class="type">IDENTIFIER</span>(country), <span class="type">SWITCH</span>, <span class="type">COLON</span>, <span class="type">INDENT</span>, <span class="type">IDENTIFIER</span>(country), <span class="type">EQUALS</span>, <span class="type">LITERAL</span>(<span class="type">PT</span>), <span class="type">ARROW</span>, <span class="type">INDENT</span>, </div><div class="line"><span class="type">CALLSERVICE</span>, <span class="type">LITERAL</span>(<span class="type">A</span>), <span class="type">EXIT</span>, <span class="type">DEDENT</span>, <span class="type">OTHERWISE</span>, <span class="type">ARROW</span>, <span class="type">INDENT</span>, <span class="type">CALLSERVICE</span>, <span class="type">LITERAL</span>(<span class="type">B</span>), <span class="type">SWITCH</span>, <span class="type">COLON</span>, </div><div class="line"><span class="type">INDENT</span>, <span class="type">IDENTIFIER</span>(name), <span class="type">EQUALS</span>, <span class="type">LITERAL</span>(unknown), <span class="type">ARROW</span>, <span class="type">INDENT</span>, <span class="type">EXIT</span>, <span class="type">DEDENT</span>, <span class="type">OTHERWISE</span>, <span class="type">ARROW</span>, </div><div class="line"><span class="type">INDENT</span>, <span class="type">CALLSERVICE</span>, <span class="type">LITERAL</span>(<span class="type">C</span>), <span class="type">EXIT</span>, <span class="type">DEDENT</span>, <span class="type">DEDENT</span>, <span class="type">DEDENT</span>, <span class="type">DEDENT</span>))</div></pre></td></tr></table></figure></p>
<h2 id="构建语法分析器"><a href="#构建语法分析器" class="headerlink" title="构建语法分析器"></a>构建语法分析器</h2><p>现在我们已经进行了词法分析，我们仍然缺少语法分析步骤，即将token序列转换为抽象语法树（AST）。 与生成<code>String</code>解析器的<code>RegexParsers</code>不同，我们将需要一个<code>WorkflowToken</code>parser。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">WorkflowParser</span> <span class="keyword">extends</span> <span class="title">Parsers</span> </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">Elem</span> </span>= <span class="type">WorkflowToken</span></div></pre></td></tr></table></figure>
<p>我们需要定义<code>Reader[WorkflowToken]</code>，被parser用来从<code>WorkflowToken</code>序列中读取数据：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkflowTokenReader</span>(<span class="params">tokens: <span class="type">Seq</span>[<span class="type">WorkflowToken</span>]</span>) <span class="keyword">extends</span> <span class="title">Reader</span>[<span class="type">WorkflowToken</span>] </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">first</span></span>: <span class="type">WorkflowToken</span> = tokens.head</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">atEnd</span></span>: <span class="type">Boolean</span> = tokens.isEmpty</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">pos</span></span>: <span class="type">Position</span> = <span class="type">NoPosition</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">rest</span></span>: <span class="type">Reader</span>[<span class="type">WorkflowToken</span>] = <span class="keyword">new</span> <span class="type">WorkflowTokenReader</span>(tokens.tail)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构建语法分析器和够贱词法分析器的过程类似。我们定义简单的解析器然后将他们组合成更复杂的解析器。只不过这次parser返回的是AST而不是token:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">WorkflowAST</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">AndThen</span>(<span class="params">step1: <span class="type">WorkflowAST</span>, step2: <span class="type">WorkflowAST</span></span>) <span class="keyword">extends</span> <span class="title">WorkflowAST</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadInput</span>(<span class="params">inputs: <span class="type">Seq</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">WorkflowAST</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CallService</span>(<span class="params">serviceName: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">WorkflowAST</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Choice</span>(<span class="params">alternatives: <span class="type">Seq</span>[<span class="type">ConditionThen</span>]</span>) <span class="keyword">extends</span> <span class="title">WorkflowAST</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Exit</span> <span class="keyword">extends</span> <span class="title">WorkflowAST</span></span></div><div class="line"></div><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">ConditionThen</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">thenBlock</span></span>: <span class="type">WorkflowAST</span> &#125;</div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">IfThen</span>(<span class="params">predicate: <span class="type">Condition</span>, thenBlock: <span class="type">WorkflowAST</span></span>) <span class="keyword">extends</span> <span class="title">ConditionThen</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherwiseThen</span>(<span class="params">thenBlock: <span class="type">WorkflowAST</span></span>) <span class="keyword">extends</span> <span class="title">ConditionThen</span></span></div><div class="line"></div><div class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Condition</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Equals</span>(<span class="params">factName: <span class="type">String</span>, factValue: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Condition</span></span></div></pre></td></tr></table></figure>
<p>作为<code>WorkflowToken</code>的parser我们继承了从<code>WorkflowToken</code>到<code>Parser[WorkflowToken]</code>的隐式转换。这对于解析无参token（如 <code>EXIT</code>，<code>CALLSERVICE</code>等）非常有用。对于<code>INENTIFIER</code>和<code>LITERAL</code>我们可以使用<code>accept</code>方法对这些token进行匹配。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">identifier</span></span>: <span class="type">Parser</span>[<span class="type">IDENTIFIER</span>] = &#123;</div><div class="line">  accept(<span class="string">"identifier"</span>, &#123; <span class="keyword">case</span> id @ <span class="type">IDENTIFIER</span>(name) =&gt; id &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">literal</span></span>: <span class="type">Parser</span>[<span class="type">LITERAL</span>] = &#123;</div><div class="line">  accept(<span class="string">"string literal"</span>, &#123; <span class="keyword">case</span> lit @ <span class="type">LITERAL</span>(name) =&gt; lit &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>语法规则可以这样实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition</span></span>: <span class="type">Parser</span>[<span class="type">Equals</span>] = &#123;</div><div class="line">  (identifier ~ <span class="type">EQUALS</span> ~ literal) ^^ &#123; <span class="keyword">case</span> id ~ eq ~ lit =&gt; <span class="type">Equals</span>(id, lit) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这与我们以前生成token类似; 这里我们将解析结果（<code>identifier</code>，<code>EQUALS</code>和<code>literal</code>）转换成<code>Equals</code>实例。注意<code>~</code>的用法。</p>
<p>剩下的规则的实现和我们上面的类似：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">program</span></span>: <span class="type">Parser</span>[<span class="type">WorkflowAST</span>] = &#123;</div><div class="line">  phrase(block)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">block</span></span>: <span class="type">Parser</span>[<span class="type">WorkflowAST</span>] = &#123;</div><div class="line">  rep1(statement) ^^ &#123; <span class="keyword">case</span> stmtList =&gt; stmtList reduceRight <span class="type">AndThen</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">statement</span></span>: <span class="type">Parser</span>[<span class="type">WorkflowAST</span>] = &#123;</div><div class="line">  <span class="keyword">val</span> exit = <span class="type">EXIT</span> ^^ (_ =&gt; <span class="type">Exit</span>)</div><div class="line">  <span class="keyword">val</span> readInput = <span class="type">READINPUT</span> ~ rep(identifier ~ <span class="type">COMMA</span>) ~ identifier ^^ &#123;</div><div class="line">    <span class="keyword">case</span> read ~ inputs ~ <span class="type">IDENTIFIER</span>(lastInput) =&gt; <span class="type">ReadInput</span>(inputs.map(_._1.str) ++ <span class="type">List</span>(lastInput))</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">val</span> callService = <span class="type">CALLSERVICE</span> ~ literal ^^ &#123;</div><div class="line">    <span class="keyword">case</span> call ~ <span class="type">LITERAL</span>(serviceName) =&gt; <span class="type">CallService</span>(serviceName)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">val</span> switch = <span class="type">SWITCH</span> ~ <span class="type">COLON</span> ~ <span class="type">INDENT</span> ~ rep1(ifThen) ~ opt(otherwiseThen) ~ <span class="type">DEDENT</span> ^^ &#123;</div><div class="line">    <span class="keyword">case</span> _ ~ _ ~ _ ~ ifs ~ otherwise ~ _ =&gt; <span class="type">Choice</span>(ifs ++ otherwise)</div><div class="line">  &#125;</div><div class="line">  exit | readInput | callService | switch</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ifThen</span></span>: <span class="type">Parser</span>[<span class="type">IfThen</span>] = &#123;</div><div class="line">  (condition ~ <span class="type">ARROW</span> ~ <span class="type">INDENT</span> ~ block ~ <span class="type">DEDENT</span>) ^^ &#123;</div><div class="line">    <span class="keyword">case</span> cond ~ _ ~ _ ~ block ~ _ =&gt; <span class="type">IfThen</span>(cond, block)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">otherwiseThen</span></span>: <span class="type">Parser</span>[<span class="type">OtherwiseThen</span>] = &#123;</div><div class="line">  (<span class="type">OTHERWISE</span> ~ <span class="type">ARROW</span> ~ <span class="type">INDENT</span> ~ block ~ <span class="type">DEDENT</span>) ^^ &#123;</div><div class="line">    <span class="keyword">case</span> _ ~ _ ~ _ ~ block ~ _ =&gt; <span class="type">OtherwiseThen</span>(block)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就像我们用词法分析器一样，我们还定义了一个<code>apply</code>方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkflowParserError</span>(<span class="params">msg: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">WorkflowCompilationError</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">WorkflowParser</span> <span class="keyword">extends</span> <span class="title">RegexParsers</span> </span>&#123;</div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(tokens: <span class="type">Seq</span>[<span class="type">WorkflowToken</span>]): <span class="type">Either</span>[<span class="type">WorkflowParserError</span>, <span class="type">WorkflowAST</span>] = &#123;</div><div class="line">    <span class="keyword">val</span> reader = <span class="keyword">new</span> <span class="type">WorkflowTokenReader</span>(tokens)</div><div class="line">    program(reader) <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> <span class="type">NoSuccess</span>(msg, next) =&gt; <span class="type">Left</span>(<span class="type">WorkflowParserError</span>(msg))</div><div class="line">      <span class="keyword">case</span> <span class="type">Success</span>(result, next) =&gt; <span class="type">Right</span>(result)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a>Pipelining</h2><p>我们现在已经实现了词法和语法分析器。 剩下的就是将它们串起来：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">WorkflowCompiler</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(code: <span class="type">String</span>): <span class="type">Either</span>[<span class="type">WorkflowCompilationError</span>, <span class="type">WorkflowAST</span>] = &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">      tokens &lt;- <span class="type">WorkflowLexer</span>(code).right</div><div class="line">      ast &lt;- <span class="type">WorkflowParser</span>(tokens).right</div><div class="line">    &#125; <span class="keyword">yield</span> ast</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>试一下样例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="type">WorkflowCompiler</span>(code)</div><div class="line">res0: <span class="type">Either</span>[<span class="type">WorkflowCompilationError</span>,<span class="type">WorkflowAST</span>] = <span class="type">Right</span>(<span class="type">AndThen</span>(<span class="type">ReadInput</span>(<span class="type">List</span>(name, country)),</div><div class="line"><span class="type">Choice</span>(<span class="type">List</span>(<span class="type">IfThen</span>(<span class="type">Equals</span>(country,<span class="type">PT</span>),<span class="type">AndThen</span>(<span class="type">CallService</span>(<span class="type">A</span>),<span class="type">Exit</span>)),<span class="type">OtherwiseThen</span>(<span class="type">AndThen</span>(<span class="type">CallService</span>(<span class="type">B</span>),</div><div class="line"><span class="type">Choice</span>(<span class="type">List</span>(<span class="type">IfThen</span>(<span class="type">Equals</span>(name,unknown),<span class="type">Exit</span>), <span class="type">OtherwiseThen</span>(<span class="type">AndThen</span>(<span class="type">CallService</span>(<span class="type">C</span>),<span class="type">Exit</span>))))))))))</div></pre></td></tr></table></figure></p>
<p> 我们的编译器已被证明能够解析代码。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>现在我们来尝试解析一个语法上无效的程序。 假设我们忘了在第一个switch case上引用<code>PT</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="type">WorkflowCompiler</span>(invalidCode)</div><div class="line">res1: <span class="type">Either</span>[<span class="type">WorkflowCompilationError</span>,<span class="type">WorkflowAST</span>] = <span class="type">Left</span>(<span class="type">WorkflowParserError</span>(string literal expected))</div></pre></td></tr></table></figure>
<p>我们得到一个明确的错误消息，告诉我们预期一个字符串字面量，但在哪里？ 知道这个错误的源位置就好了。 幸运的是，Scala的parser combinator支持记录token的原始源位置。</p>
<p>为了做到这一点，首先，我们的<code>WorkflowToken</code>和<code>WorkflowAST</code> trait 必须与<code>Positional</code>混合。 这提供了一个可变的<code>pos</code>变量和一个<code>setPos</code>方法，该方法可以用行号和列号修饰对应的实例。</p>
<p>其次，我们必须在每个解析器上使用<code>positioned</code>运算符。 例如，<code>IDENTIFIER</code> token 的解析器将被写为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">identifier</span></span>: <span class="type">Parser</span>[<span class="type">IDENTIFIER</span>] = positioned &#123;</div><div class="line">  <span class="string">"[a-zA-Z_][a-zA-Z0-9_]*"</span>.r ^^ &#123; str =&gt; <span class="type">IDENTIFIER</span>(str) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Positional</code> Mixin的一个丑陋的副作用是，我们所有的令牌现在都必须成为case class 而不是case object，因为每个人现在都拥有可变状态。</p>
<p>我们的<code>WorkflowCompilationError</code>子类型现在包括位置信息…</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkflowLexerError</span>(<span class="params">location: <span class="type">Location</span>, msg: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">WorkflowCompilationError</span></span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkflowParserError</span>(<span class="params">location: <span class="type">Location</span>, msg: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">WorkflowCompilationError</span></span></div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Location</span>(<span class="params">line: <span class="type">Int</span>, column: <span class="type">Int</span></span>) </span>&#123;</div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"<span class="subst">$line</span>:<span class="subst">$column</span>"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>…由每个阶段的<code>apply</code>方法报告：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(code: <span class="type">String</span>): <span class="type">Either</span>[<span class="type">WorkflowLexerError</span>, <span class="type">List</span>[<span class="type">WorkflowToken</span>]] = &#123;</div><div class="line">  parse(tokens, code) <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">NoSuccess</span>(msg, next) =&gt; <span class="type">Left</span>(<span class="type">WorkflowLexerError</span>(<span class="type">Location</span>(next.pos.line, next.pos.column), msg))</div><div class="line">    <span class="keyword">case</span> <span class="type">Success</span>(result, next) =&gt; <span class="type">Right</span>(result)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们再试一次解析无效的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="type">WorkflowCompiler</span>(invalidCode)</div><div class="line">res1: <span class="type">Either</span>[<span class="type">WorkflowCompilationError</span>,<span class="type">WorkflowAST</span>] = <span class="type">Left</span>(<span class="number">3</span>:<span class="number">14</span>,<span class="type">WorkflowParserError</span>(string literal expected))</div></pre></td></tr></table></figure></p>
<h2 id="Final-notes"><a href="#Final-notes" class="headerlink" title="Final notes"></a>Final notes</h2><p>我们从一个文本流分解成一系列token，最终将它们组合成一个类型化的抽象语法树，从而导致一个更有效的方法来推导程序。</p>
<p>我们现在可以扩展编译器以执行其他非解析相关任务，比如验证（例如，确保所有代码路径以<code>exit</code>关键字结尾）或代码生成，即遍历此AST以生成指令序列。</p>
<p>如果您想继续使用Scala的parser combinator，则可以在以下网址获取本教程的最终代码：<a href="https://github.com/enear/parser-combinators-tutorial" target="_blank" rel="external">https://github.com/enear/parser-combinators-tutorial</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然有几个关于如何使用Parser Combinator构建简单解析器的资源，但迄今为止还没有描述如何从头开始构建完整的词法和语法分析器。&lt;/p&gt;
&lt;p&gt;下面将介绍如何构建词法分析器来将文本转化成一系列token，以及构建解析器将token解析为抽象语法树（AST）。&lt;/p
    
    </summary>
    
      <category term="scala" scheme="http://mtunique.com/categories/scala/"/>
    
    
      <category term="scala" scheme="http://mtunique.com/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>Flink Table/SQL API 规划 —— Dynamic Table</title>
    <link href="http://mtunique.com/flink_sql_outlook/"/>
    <id>http://mtunique.com/flink_sql_outlook/</id>
    <published>2017-03-26T05:40:00.000Z</published>
    <updated>2017-03-27T07:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">动态表的概念是社区很早就提出的但并没有全部实现下文中所有介绍都是基于已有规划和proposal给出的，可能与之后实现存在出入仅供参考</div></pre></td></tr></table></figure>
<p><img src="https://dn-mtunique.qbox.me/dyn_table_pipline.jpg" alt=""></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>动态表直观上看是一个类似于数据库中的<code>Materialized View</code>概念。动态表随着时间改变；类似静态的batch table一样可以用标准SQL进行查询然后一个新的动态表；可以和流无损地互相转换(对偶的)。对现有的API最大的改进关键在表的内容随着时间改变，而现在的状态只是append。当前的streaming table可以认为是一种动态表，append模式的动态表。</p>
<a id="more"></a>
<h2 id="流到-Dynamic-Table"><a href="#流到-Dynamic-Table" class="headerlink" title="流到 Dynamic Table"></a>流到 Dynamic Table</h2><p>流被转换成Table时决定选择哪种模式是依据表的schema是否定义primary key。</p>
<h3 id="Append模式："><a href="#Append模式：" class="headerlink" title="Append模式："></a>Append模式：</h3><p>如果表的schema没有包括key的定义那转换成表时采用append模式。把流中每条新来的record当做新的row append到表中。一旦数据加到表中就不能再被更新和删除(指当前表中，不考虑转换成新表)。</p>
<p><img src="https://dn-mtunique.qbox.me/stream2t_append.jpg" alt=""></p>
<h3 id="Replace模式："><a href="#Replace模式：" class="headerlink" title="Replace模式："></a>Replace模式：</h3><p>相对应，如果定义了key，那么对于流中的每条记录如果key不在表中就insert否则就update。</p>
<p><img src="https://dn-mtunique.qbox.me/stream2t_replace.jpg" alt=""></p>
<h2 id="Dynamic-Table-到-流"><a href="#Dynamic-Table-到-流" class="headerlink" title="Dynamic Table 到 流"></a>Dynamic Table 到 流</h2><p>表到流的操作是把表的所有change以changelog stream的方式发送到下游。这一步也有两种模式。</p>
<h3 id="Retraction模式："><a href="#Retraction模式：" class="headerlink" title="Retraction模式："></a>Retraction模式：</h3><p>traction模式中对于Dynamic Table的insert和delete的change分别产生insert或delete event。如果是update的change会产生两种change event，对于之前发送出去的同样key的record会产生delete event，对于当前的record是产生insert event。如下图所示：</p>
<p><img src="https://dn-mtunique.qbox.me/t2stream_retract.jpg" alt=""></p>
<h3 id="Update模式："><a href="#Update模式：" class="headerlink" title="Update模式："></a>Update模式：</h3><p>update模式依赖Dynamic Table定义了key。所有的change event是一个kv对。key对应表的key在当前record中的值；对于insert和change value对应新的record。对于delete value是空表示该可以已经被删除。如下图所示：</p>
<p><img src="https://dn-mtunique.qbox.me/t2stream_replace.jpg" alt=""></p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>表的内容随着时间改变意味着对表的query结果也是随着时间改变的。我们定义：</p>
<ul>
<li>A[t]: 时间t时的表A</li>
<li>q(A[t])：时间t时对表A执行query q</li>
</ul>
<p>举个例子来理解动态表的概念：</p>
<p><img src="https://dn-mtunique.qbox.me/dyn_table_example.jpg" alt=""></p>
<h2 id="query的限制"><a href="#query的限制" class="headerlink" title="query的限制"></a>query的限制</h2><p>由于流是无限的，相对应 Dynamic Table 也是无界的。当查询无限的表的时候我们需要保证query的定时是良好的，有意义可行的。</p>
<p>1.在实践中Flink将查询转换成持续的流式应用，执行的query仅针对当前的逻辑时间，所以不支持对于任意时间点的查询(A[t])。<br>2.最直观的原则是query可能的状态和计算必须是有界的，所以可以支持可增量计算的查询：</p>
<ul>
<li>不断更新当前结果的查询：查询可以产生insert，update和delete更改。查询可以表示为 <code>Q(t+1) = q&#39;(Q(t), c(T, t, t+1))</code>，其中Q(t)是query q的前一次查询结果，c(T, t, t_+1) 是表T从t+1到t的变化, q’是q的增量版本。</li>
<li>产生append-only的表，可以从输入表的尾端直接计算出新数据。查询可以表示为 <code>Q(t+1) = q&#39;&#39;(c(T, t-x, t+1)) ∪ Q(t)</code>，q’’是不需要时间t时q的结果增量版本query q。c(T, t-x, t+1)是表T尾部的x+1个数据，x取决于语义。例如最后一小时的window aggregation至少需要最后一小时的数据作为状态。其他能支持的查询类型还有：单独在每一行上操作的SELECT WHERE；rowtime上的GROUP BY子句（比如基于时间的window aggregate）；ORDER BY rowtime的OVER windows(row-windows)；ORDER BY rowtime。<br>3.当输入表足够小时，对表的每条数据进行访问。比如对两个大小固定的流表(比如key的个数固定)进行join。</li>
</ul>
<h2 id="中间状态有界"><a href="#中间状态有界" class="headerlink" title="中间状态有界"></a>中间状态有界</h2><p>如上文所说的，某些增量查询需要保留一些数据（部分输入数据或者中间结果）作为状态。为了保证query不会失败，保证查询所需要的空间是有界的不随着时间无限增长很重要。主要有两个原因使得状态增长：</p>
<ol>
<li>不受时间谓词约束的中间计算状态的增长（比如 聚合key的膨胀）</li>
<li>时间有界但是需要迟到的数据（比如 window 的聚合）</li>
</ol>
<p>虽然第二种情况可有通过下文提到的”Last Result Offset”参数解决，但是第一种情况需要优化器检测。我们应该拒绝不受时间限制的中间状态增长的查询。优化器应该提供如何修复查询且要求有适当的时间谓词。比如下面这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, page, <span class="keyword">COUNT</span>(page) <span class="keyword">AS</span> pCnt</div><div class="line"><span class="keyword">FROM</span> pageviews</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">user</span>, page</div></pre></td></tr></table></figure>
<p>随着用户数和页面数的增长，中间状态会数据随着时间推移而增长。对于存储空间的要求可以通过添加时间谓词来限制：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, page, <span class="keyword">COUNT</span>(page) <span class="keyword">AS</span> pCnt</div><div class="line"><span class="keyword">FROM</span> pageviews</div><div class="line"><span class="keyword">WHERE</span> rowtime <span class="keyword">BETWEEN</span> <span class="keyword">now</span>() - <span class="built_in">INTERVAL</span> <span class="string">'1'</span> <span class="keyword">HOUR</span> <span class="keyword">AND</span> <span class="keyword">now</span>() // <span class="keyword">only</span> <span class="keyword">last</span> <span class="keyword">hour</span></div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">user</span>, page</div></pre></td></tr></table></figure>
<p>因为不是所有属性都是不断增长的, 因此可以告诉优化器domain的size, 就可以推断中间状态不会随着时间推移而增长，然后接受没有时间谓词的查询。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sensorT: <span class="type">Table</span> = sensors</div><div class="line">  .toTable(<span class="symbol">'id</span>, <span class="symbol">'loc</span>, <span class="symbol">'stime</span>, <span class="symbol">'temp</span>)</div><div class="line">  .attributeDomain(<span class="symbol">'loc</span>, <span class="type">Domain</span>.constant) <span class="comment">// domain of 'loc is not growing </span></div><div class="line">env.registerTable(<span class="string">"sensors"</span>, sensorT)</div><div class="line"></div><div class="line"><span class="type">SELECT</span> loc, <span class="type">AVG</span>(temp) <span class="type">AS</span> avgTemp</div><div class="line"><span class="type">FROM</span> sensors</div><div class="line"><span class="type">GROUP</span> <span class="type">BY</span> loc</div></pre></td></tr></table></figure>
<h2 id="结果的计算和细化时序"><a href="#结果的计算和细化时序" class="headerlink" title="结果的计算和细化时序"></a>结果的计算和细化时序</h2><p>一些关系运算符必须等数据到达才能计算最终结果。例如：在10：30关闭的窗口至少要等到10：30才能计算出最终的结果。Flink的logical clock（即 决定何时才是10：30）取决于使用event time 还是 processing time。在processing time的情况下，logical time是每个机器的wallclock；在event time的情况下，logical clock time是由源头提供的watermark决定的。由于数据的乱序和延迟当在event time模式下时等待一段时间来减小计算结果不完整性。另一方面某些情况下希望得到不断改进的早期结果。因此对于结果被计算、改进或者做出最终结果时有不同的要求、</p>
<p>下图描绘了不同的配置参数如何用于控制早期结果和细化计算结果的。</p>
<p><img src="https://dn-mtunique.qbox.me/time_conf.jpg" alt=""></p>
<ul>
<li>“First Result Offset” 指第一个早期结果被计算的结果的时间。时间是相对于第一次可以计算完整结果的时间（比如相对于window的结束时间10:30）。如果设置的是-10分钟，对于结束时间是10：30的window那么第一个被发出去的结果是在逻辑时间10：20计算的。这个参数的默认值是0，即在window结束的时候才计算结果。</li>
<li>“Complete Result Offset” 指完整的结果被计算的时间。时间是相对于第一次可以计算完整的时间。如果设置的是+5分钟，对于结束时间是10：30的window那么产生完整结果的时间是10：35。这个参数可以减轻延迟数据造成的影响。默认是0，即在window结束的时候计算的结果就是完整结果。</li>
<li>“Update Rate” 指计算完整结果之前一次次更新结果的时间间隔（可以是时间和次数）。如果设为5分钟，窗口大小是30分钟的tumbling window，开始时间是10：300，”First Result Offset”是-15分钟， “Complete Result Offset”是2分钟，那么将在10:20, 10:25, 10：30更新结果，10:15禅城寄一个结果，10：32产生完整结果。</li>
<li>“Last Updates Switch” 指完整结果发出后对于延迟的数据是否计算延迟更新，直到计算状态被清除。</li>
<li>“Last Result Offset” 指可计算的最后一个结果的时间。这是内部状态被清除的时间，清除状态后再到达的数据将被丢弃。Last Result Offset 意味着计算的结果是近似值，不能保证精确。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;动态表的概念是社区很早就提出的但并没有全部实现下文中所有介绍都是基于已有规划和proposal给出的，可能与之后实现存在出入仅供参考&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-mtunique.qbox.me/dyn_table_pipline.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;动态表直观上看是一个类似于数据库中的&lt;code&gt;Materialized View&lt;/code&gt;概念。动态表随着时间改变；类似静态的batch table一样可以用标准SQL进行查询然后一个新的动态表；可以和流无损地互相转换(对偶的)。对现有的API最大的改进关键在表的内容随着时间改变，而现在的状态只是append。当前的streaming table可以认为是一种动态表，append模式的动态表。&lt;/p&gt;
    
    </summary>
    
      <category term="big-data" scheme="http://mtunique.com/categories/big-data/"/>
    
      <category term="flink" scheme="http://mtunique.com/categories/big-data/flink/"/>
    
    
      <category term="big-data" scheme="http://mtunique.com/tags/big-data/"/>
    
      <category term="flink" scheme="http://mtunique.com/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>浅析 Flink Table/SQL API</title>
    <link href="http://mtunique.com/flink_sql/"/>
    <id>http://mtunique.com/flink_sql/</id>
    <published>2017-03-21T14:38:00.000Z</published>
    <updated>2017-04-08T10:32:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从何而来"><a href="#从何而来" class="headerlink" title="从何而来"></a>从何而来</h2><p>关系型API有很多好处：是声明式的，用户只需要告诉需要什么，系统决定如何计算；用户不必特地实现；更方便优化，可以执行得更高效。本身Flink就是一个统一批和流的分布式计算平台，所以社区设计关系型API的目的之一是可以让关系型API作为统一的一层，两种查询拥有同样的语义和语法。大多数流处理框架的API都是比较low-level的API，学习成本高而且很多逻辑需要写到UDF中，所以Apache Flink 添加了SQL-like的API处理关系型数据–Table API。这套API中最重要的概念是<code>Table</code>(可以在上面进行关系型操作的结构化的DataSet或DataStream)。<code>Table</code> API 与 <code>DataSet</code>和<code>DataStream</code> API 结合紧密，DataSet 和 DataStream都可以很容易地转换成 Table，同样转换回来也很方便：</p>
<a id="more"></a>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> execEnv = <span class="type">ExecutionEnvironment</span>.getExecutionEnvironment</div><div class="line"><span class="keyword">val</span> tableEnv = <span class="type">TableEnvironment</span>.getTableEnvironment(execEnv)</div><div class="line"></div><div class="line"><span class="comment">// obtain a DataSet from somewhere</span></div><div class="line"><span class="keyword">val</span> tempData: <span class="type">DataSet</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Double</span>)] =</div><div class="line"></div><div class="line"><span class="comment">// convert the DataSet to a Table</span></div><div class="line"><span class="keyword">val</span> tempTable: <span class="type">Table</span> = tempData.toTable(tableEnv, <span class="symbol">'location</span>, <span class="symbol">'time</span>, <span class="symbol">'tempF</span>)</div><div class="line"><span class="comment">// compute your result</span></div><div class="line"><span class="keyword">val</span> avgTempCTable: <span class="type">Table</span> = tempTable</div><div class="line"> .where(<span class="symbol">'location</span>.like(<span class="string">"room%"</span>))</div><div class="line"> .select(</div><div class="line">   (<span class="symbol">'time</span> / (<span class="number">3600</span> * <span class="number">24</span>)) as <span class="symbol">'day</span>, </div><div class="line">   <span class="symbol">'Location</span> as <span class="symbol">'room</span>, </div><div class="line">   ((<span class="symbol">'tempF</span> - <span class="number">32</span>) * <span class="number">0.556</span>) as <span class="symbol">'tempC</span></div><div class="line">  )</div><div class="line"> .groupBy(<span class="symbol">'day</span>, <span class="symbol">'room</span>)</div><div class="line"> .select(<span class="symbol">'day</span>, <span class="symbol">'room</span>, <span class="symbol">'tempC</span>.avg as <span class="symbol">'avgTempC</span>)</div><div class="line"><span class="comment">// convert result Table back into a DataSet and print it</span></div><div class="line">avgTempCTable.toDataSet[<span class="type">Row</span>].print()</div></pre></td></tr></table></figure>
<p>example使用的是Scala的API，Java版API也有同样的功能。</p>
<p>下图展示了 Table API 的架构:</p>
<p><img src="https://dn-mtunique.qbox.me/flink_table_arch.jpg" alt=""></p>
<p>从 DataSet 或 DataStream 创建一个 Table，然后在上面进行关系型操作比如 <code>fliter</code>、<code>join</code>、<code>select</code>。对Table的操作将会转换成逻辑运算符树。Table 转换回 DataSet 和 DataStream 的时候将会转换成DataSet 和 DataStream的算子。有些类似 <code>&#39;location.like(&quot;room%&quot;)</code> 的表达式将会通过 <code>code generation</code> 编译成Flink的函数。</p>
<p>然而，最初传统的Table API 有一定的限制。首先，它不能独立使用。Table API 的 query 必须嵌入到 DataSet 或 DataStream的程序中。对批处理表的查询不支持<code>outer join</code>，<code>sorting</code>和很多SQL中常见的标量函数。对于流处理的查询只支持<code>filtetr</code> <code>union</code> 和 <code>projection</code>，不支持<code>aggregation</code>和<code>join</code>。而且，转换过程中没有利用太多查询优化技术，除了适用于所有DataSet程序的优化。</p>
<h2 id="Table-API-和-SQL-紧密结合"><a href="#Table-API-和-SQL-紧密结合" class="headerlink" title="Table API 和 SQL 紧密结合"></a>Table API 和 SQL 紧密结合</h2><p>随着流处理的日益普及和Flink在该领域的增长，Flink社区认为需要一个更简单的API使更多的用户能够分析流数据。一年前Flink社区决定将Table API提升到一个新的层级，扩展Table API中流处理的能力以及支持SQL。社区不想重复造轮子，于是决定在 <a href="https://calcite.apache.org/" target="_blank" rel="external">Apache Calcite</a> (一个比较流行的SQL解析和优化框架)的基础上构建新的 Table API。Apache Calcite 被用在很多项目中，包括 Apache Hive，Apache Drill，Cascading等等。除此之外，Calcite社区将 <a href="https://calcite.apache.org/docs/stream.html" target="_blank" rel="external">SQL on Stream</a> 写入它的roadmap，所以Flink的SQL很适合和它结合。</p>
<p>以Calcite为核心的新架构图:</p>
<p><img src="https://dn-mtunique.qbox.me/flink_sql_arch.jpg" alt=""></p>
<p>新架构提供两种API进行关系型查询，Table API 和 SQL。这两种API的查询都会用包含注册过的Table的catalog进行验证，然后转换成统一Calcite的logical plan。在这种表示中，stream和batch的查询看起来完全一样。下一步，利用 Calcite的 cost-based 优化器优化转换规则和logical plan。根据数据源的性质(流式和静态)使用不同的规则进行优化。最终优化后的plan转传成常规的Flink DataSet 或 DataStream 程序。这步还涉及code generation（将关系表达式转换成Flink函数）。</p>
<p>下面我们举一个例子来理解新的架构。表达式转换成Logical Plan如下图所示：</p>
<p><img src="https://dn-mtunique.qbox.me/to_logical_plan.jpg" alt=""></p>
<p>调用Table API 实际上是创建了很多 Table API 的 <code>LogicalNode</code>，创建的过程中对会对整个query进行validate。比如table是<code>CalalogNode</code>，window groupBy之后在select时会创建<code>WindowAggregate</code>和<code>Project</code>，where对应<code>Filter</code>。然后用<code>RelBuilder</code>翻译成Calcite LogicalPlan。如果是SQL API 将直接用Calcite的Parser进行解释然后validate生成Calcite LogicalPlan。</p>
<p><img src="https://dn-mtunique.qbox.me/trans.jpg" alt=""></p>
<p>利用Calcite内置的一些rule来优化LogicalPlan，也可以自己添加或者覆盖这些rule。转换成Optimized Calcite Plan后，仍然是Calcite的内部表示方式，现在需要transform成DataStream Plan，对应上图第三列的类，里面封装了如何translate成普通的DataStream或DataSet程序。随后调用相应的<code>tanslateToPlan</code>方法转换和利用CodeGen元编程成Flink的各种算子。现在就相当于我们直接利用Flink的DataSet或DataStream API开发的程序。</p>
<p>Table API的新架构除了维持最初的原理还改进了很多。为流式数据和静态数据的关系查询保留统一的接口，而且利用了Calcite的查询优化框架和SQL parser。该设计是基于Flink已构建好的API构建的，DataStream API 提供低延时高吞吐的流处理能力而且就有exactly-once语义而且可以基于event-time进行处理。而且DataSet拥有稳定高效的内存算子和流水线式的数据交换。Flink的core API和引擎的所有改进都会自动应用到Table API和SQL上。</p>
<p>新的SQL接口集成到了Table API中。DataSteam， DataSet和外部数据源可以在TableEnvironment中注册成表，为了是他们可以通过SQL进行查询。<code>TableEnvironment.sql()</code>方法用来声明SQL和将结果作为Table返回。下面的是一个完整的样例，从一个JSON编码的Kafka topic中读取流表，然后用SQL处理并写到另一个Kafka topic。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// get environments</span></div><div class="line"><span class="keyword">val</span> execEnv = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</div><div class="line"><span class="keyword">val</span> tableEnv = <span class="type">TableEnvironment</span>.getTableEnvironment(execEnv)</div><div class="line"></div><div class="line"><span class="comment">// configure Kafka connection</span></div><div class="line"><span class="keyword">val</span> kafkaProps = ...</div><div class="line"><span class="comment">// define a JSON encoded Kafka topic as external table</span></div><div class="line"><span class="keyword">val</span> sensorSource = <span class="keyword">new</span> <span class="type">KafkaJsonSource</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Double</span>)](</div><div class="line">    <span class="string">"sensorTopic"</span>,</div><div class="line">    kafkaProps,</div><div class="line">    (<span class="string">"location"</span>, <span class="string">"time"</span>, <span class="string">"tempF"</span>))</div><div class="line"></div><div class="line"><span class="comment">// register external table</span></div><div class="line">tableEnv.registerTableSource(<span class="string">"sensorData"</span>, sensorSource)</div><div class="line"></div><div class="line"><span class="comment">// define query in external table</span></div><div class="line"><span class="keyword">val</span> roomSensors: <span class="type">Table</span> = tableEnv.sql(</div><div class="line">    <span class="string">"SELECT STREAM time, location AS room, (tempF - 32) * 0.556 AS tempC "</span> +</div><div class="line">    <span class="string">"FROM sensorData "</span> +</div><div class="line">    <span class="string">"WHERE location LIKE 'room%'"</span></div><div class="line">  )</div><div class="line"></div><div class="line"><span class="comment">// define a JSON encoded Kafka topic as external sink</span></div><div class="line"><span class="keyword">val</span> roomSensorSink = <span class="keyword">new</span> <span class="type">KafkaJsonSink</span>(...)</div><div class="line"></div><div class="line"><span class="comment">// define sink for room sensor data and execute query</span></div><div class="line">roomSensors.toSink(roomSensorSink)</div><div class="line">execEnv.execute()</div></pre></td></tr></table></figure>
<p>这个样例中忽略了流处理中最有趣的部分：window aggregate 和 join。这些操作如何用SQL表达呢？Apache Calcite社区提出了一个proposal来讨论<a href="https://calcite.apache.org/docs/stream.html" target="_blank" rel="external">SQL on streams</a>的语法和语义。社区将Calcite的stream SQL描述为标准SQL的扩展而不是另外的 SQL-like语言。这有很多好处，首先，熟悉SQL标准的人能够在不学习新语法的情况下分析流数据。静态表和流表的查询几乎相同，可以轻松地移植。此外，可以同时在静态表和流表上进行查询，这和flink的愿景是一样的，将批处理看做特殊的流处理(批看作是有限的流)。最后，使用标准SQL进行流处理意味着有很多成熟的工具支持。</p>
<p>下面的example展示了如何用SQL和Table API进行滑动窗口查询:</p>
<p>SQL<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> STREAM</div><div class="line">  TUMBLE_END(<span class="keyword">time</span>, <span class="built_in">INTERVAL</span> <span class="string">'1'</span> <span class="keyword">DAY</span>) <span class="keyword">AS</span> <span class="keyword">day</span>,</div><div class="line">  location <span class="keyword">AS</span> room,</div><div class="line">  <span class="keyword">AVG</span>((tempF - <span class="number">32</span>) * <span class="number">0.556</span>) <span class="keyword">AS</span> avgTempC</div><div class="line"><span class="keyword">FROM</span> sensorData</div><div class="line"><span class="keyword">WHERE</span> location <span class="keyword">LIKE</span> <span class="string">'room%'</span></div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(<span class="keyword">time</span>, <span class="built_in">INTERVAL</span> <span class="string">'1'</span> <span class="keyword">DAY</span>), location</div></pre></td></tr></table></figure></p>
<p>Table API<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> avgRoomTemp: <span class="type">Table</span> = tableEnv.ingest(<span class="string">"sensorData"</span>)</div><div class="line">  .where(<span class="symbol">'location</span>.like(<span class="string">"room%"</span>))</div><div class="line">  .partitionBy(<span class="symbol">'location</span>)</div><div class="line">  .window(<span class="type">Tumbling</span> every <span class="type">Days</span>(<span class="number">1</span>) on <span class="symbol">'time</span> as <span class="symbol">'w</span>)</div><div class="line">  .select(<span class="symbol">'w</span>.end, <span class="symbol">'location</span>, , ((<span class="symbol">'tempF</span> - <span class="number">32</span>) * <span class="number">0.556</span>).avg as <span class="symbol">'avgTempCs</span>)</div></pre></td></tr></table></figure></p>
<h2 id="Table-API的现状"><a href="#Table-API的现状" class="headerlink" title="Table API的现状"></a>Table API的现状</h2><h3 id="Batch-SQL-amp-Table-API-支持"><a href="#Batch-SQL-amp-Table-API-支持" class="headerlink" title="Batch SQL &amp; Table API 支持:"></a>Batch SQL &amp; Table API 支持:</h3><ul>
<li>Selection, Projection, Sort, Inner &amp; Outer Joins, Set operations</li>
<li>Windows for Slide, Tumble, Session</li>
</ul>
<h3 id="Streaming-Table-API-支持"><a href="#Streaming-Table-API-支持" class="headerlink" title="Streaming Table API 支持:"></a>Streaming Table API 支持:</h3><ul>
<li>Selection, Projection, Union</li>
<li>Windows for Slide, Tumble, Session</li>
</ul>
<h3 id="Streaming-SQL"><a href="#Streaming-SQL" class="headerlink" title="Streaming SQL:"></a>Streaming SQL:</h3><ul>
<li>Selection, Projection, Union, Tumble</li>
</ul>
<h2 id="Streaming-SQL案例"><a href="#Streaming-SQL案例" class="headerlink" title="Streaming SQL案例"></a>Streaming SQL案例</h2><h3 id="持续的ETL和数据导入"><a href="#持续的ETL和数据导入" class="headerlink" title="持续的ETL和数据导入"></a>持续的ETL和数据导入</h3><p><img src="https://dn-mtunique.qbox.me/flink_stream_etl.jpg" alt=""></p>
<p>获取流式数据，然后转换这些数据（归一化，聚合…），将其写入其他系统（File，Kafka，DBMS）。这些query的结果通常会存储到log-style的系统。</p>
<h3 id="实时的Dashboards-和-报表"><a href="#实时的Dashboards-和-报表" class="headerlink" title="实时的Dashboards 和 报表"></a>实时的Dashboards 和 报表</h3><p><img src="https://dn-mtunique.qbox.me/flink_online_dashboard.jpg" alt=""></p>
<p>获取流式数据，然后对数据进行聚合来支持在线系统（dashboard，推荐）或者数据分析系统（Tableau）。通常结果被写到k-v存储中（Cassandra，Hbase，可查询的Flink状态），建立索引（Elasticsearch）或者DBMS（MySQL，PostgreSQL…）。这些查询通常可以被更新，改进。</p>
<h3 id="即席分析"><a href="#即席分析" class="headerlink" title="即席分析"></a>即席分析</h3><p><img src="https://dn-mtunique.qbox.me/flink_adhoc.jpg" alt=""></p>
<p>针对流数据的即席查询，以实时的方式进行分析和浏览数据。查询结果直接显示在notebook（Apache Zeppelin）中。</p>
<p>Flink社区还提出来和数据库中<code>Materialized View</code>很相似的<code>Dynamic table 动态表</code>概念，将在以后的版本中支持，具体细节将另开文章解释。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从何而来&quot;&gt;&lt;a href=&quot;#从何而来&quot; class=&quot;headerlink&quot; title=&quot;从何而来&quot;&gt;&lt;/a&gt;从何而来&lt;/h2&gt;&lt;p&gt;关系型API有很多好处：是声明式的，用户只需要告诉需要什么，系统决定如何计算；用户不必特地实现；更方便优化，可以执行得更高效。本身Flink就是一个统一批和流的分布式计算平台，所以社区设计关系型API的目的之一是可以让关系型API作为统一的一层，两种查询拥有同样的语义和语法。大多数流处理框架的API都是比较low-level的API，学习成本高而且很多逻辑需要写到UDF中，所以Apache Flink 添加了SQL-like的API处理关系型数据–Table API。这套API中最重要的概念是&lt;code&gt;Table&lt;/code&gt;(可以在上面进行关系型操作的结构化的DataSet或DataStream)。&lt;code&gt;Table&lt;/code&gt; API 与 &lt;code&gt;DataSet&lt;/code&gt;和&lt;code&gt;DataStream&lt;/code&gt; API 结合紧密，DataSet 和 DataStream都可以很容易地转换成 Table，同样转换回来也很方便：&lt;/p&gt;
    
    </summary>
    
      <category term="big-data" scheme="http://mtunique.com/categories/big-data/"/>
    
      <category term="flink" scheme="http://mtunique.com/categories/big-data/flink/"/>
    
    
      <category term="big-data" scheme="http://mtunique.com/tags/big-data/"/>
    
      <category term="flink" scheme="http://mtunique.com/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>【未完成】spark和flink的内存管理简单介绍和对比</title>
    <link href="http://mtunique.com/spark_flink_mem/"/>
    <id>http://mtunique.com/spark_flink_mem/</id>
    <published>2016-12-24T03:30:00.000Z</published>
    <updated>2017-03-21T14:37:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要做内存管理"><a href="#为什么要做内存管理" class="headerlink" title="为什么要做内存管理"></a>为什么要做内存管理</h1><p>最近几年存储和网络硬件的升级对大数据领域相关的系统性能提升很大，在很多场景中CPU和内存的渐渐成为瓶颈。<br>然而大数据领域很多开源框架都使用JVM。相对 c/c++ JVM系语言对于CPU和内存的利用还是差很多的，主要体现在:</p>
<ul>
<li>GC的开销较大，Full GC更会极大影响性能，尤其是对于为了处理更大数据开辟了极大内存空间的JVM来说。</li>
<li>Java对象的存储密度低。一个对象头就8字节，为了对齐有的时候还要补齐。Java对象的内存很难利用CPU的各级cache，对于 <code>avx</code> <code>simd</code> 等技术很难利用起来难以发挥CPU的这些优势。</li>
<li>OOM的问题影响稳定性。在大数据领域经常会遇到OOM的问题，除了影响稳定性之外，JVM崩溃后重新拉起的代价也很高。</li>
</ul>
<p>为了解决这些问题spark flink hbase hive 等各大框架都在自己管理内存。框架自己比JVM更了解自己的内存，更熟悉生命周期，拥有更多的信息来管理内存。</p>
<p>// 直接的意思是”绕过”JVM的内存管理机制自己管理每一个字节，就像写C一样，而不是new出来等着GC；另一方面是指通过定制的序列化工具等技术直接操作数据内容不必全部反序列化或不反序列化。</p>
<h1 id="统一管理内存"><a href="#统一管理内存" class="headerlink" title="统一管理内存"></a>统一管理内存</h1><p>内存中的Java对象越少, GC压力越小，而且可以保证统一管理的内存一直呆在老年代，而且也可以是堆外内存。</p>
<p>Spark 和 Flink 都支持堆内和堆外两种内存的管理。管理的策略都和操作系统类似，对内存进行分段分页。两者都是一级页表。</p>
<ul>
<li><p>Spark：页表的大小是 <code>1 &lt;&lt; 13</code>, 每个页(<code>MemoryBlock</code>)的大小不确定。on-heap模式时候能表示的最大页大小受限于long[]数组的最大长度，理论上最大能表示8192<em>2^32<em>**</em></em>8字节(35T)。on-heap模式时如果页超过1M会触发bufferPools来复用long数组(<code>HeapMemoryAllocator</code>)。<code>TaskMemoryManager</code>接管Task的内存分配释放，”寻址”，分配的内存页大小不固定，具体执行内存申请是由<code>HeapMemoryAllocator</code>和<code>UnsafeMemoryAllocator</code>进行。</p>
</li>
<li><p>Flink: <code>MemoryManager</code>接管内存分配和释放，构造时页的大小固定，页表大小根据需要的内存反推。<code>TaskManagerServices</code>构造<code>MemoryManager</code>时会将页大小定为<code>networkBufferSize</code>, 默认大小为32KB, 为了配合flink的Network Buffer管理。<code>AbstractPagedInputView</code>, <code>AbstractPagedOutputView</code>以及各种InputView OutputView 用来进行跨page读写内存。</p>
</li>
</ul>
<p>这些缓解了GC耗时和抖动问题。</p>
<h1 id="spill到内存外持久化存储"><a href="#spill到内存外持久化存储" class="headerlink" title="spill到内存外持久化存储"></a>spill到内存外持久化存储</h1><p>具体原理和为什么都不叫显然，两者实现也没有什么差别。</p>
<ul>
<li>Flink: 由内存使用者管理spill规则，并不像操作系统一样。比如: <code>MutableHashTable</code>，<code>SpillingBuffer</code>…</li>
<li>Spark: 同样由各类使用者各自管理，所有内存的消费者都继承<code>MemoryConsumer</code> abstract class， 实现具体spill方法。相对Flink更整洁，统一。<code>BytesToBytesMap</code>，<code>ExternalAppendOnlyMap</code>，<code>ExternalSorter</code>会spill到disk。</li>
</ul>
<h1 id="列方式存储"><a href="#列方式存储" class="headerlink" title="列方式存储"></a>列方式存储</h1><p>根据空间局部性原理，做到缓存友好首先对数据进行向量化存储。通常我们都是对结构化数据的一”列”进行相同的处理，所以</p>
<h1 id="缓存友好算法"><a href="#缓存友好算法" class="headerlink" title="缓存友好算法"></a>缓存友好算法</h1><h1 id="codegen-SIMD-AVX"><a href="#codegen-SIMD-AVX" class="headerlink" title="codegen (SIMD AVX)"></a>codegen (SIMD AVX)</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要做内存管理&quot;&gt;&lt;a href=&quot;#为什么要做内存管理&quot; class=&quot;headerlink&quot; title=&quot;为什么要做内存管理&quot;&gt;&lt;/a&gt;为什么要做内存管理&lt;/h1&gt;&lt;p&gt;最近几年存储和网络硬件的升级对大数据领域相关的系统性能提升很大，在很多场景中CPU和
    
    </summary>
    
      <category term="big-data" scheme="http://mtunique.com/categories/big-data/"/>
    
      <category term="spark" scheme="http://mtunique.com/categories/big-data/spark/"/>
    
    
      <category term="big-data" scheme="http://mtunique.com/tags/big-data/"/>
    
      <category term="flink" scheme="http://mtunique.com/tags/flink/"/>
    
      <category term="spark" scheme="http://mtunique.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>Docker 调试技巧</title>
    <link href="http://mtunique.com/docker_debug/"/>
    <id>http://mtunique.com/docker_debug/</id>
    <published>2016-12-17T14:30:00.000Z</published>
    <updated>2017-03-26T05:38:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="『重用』容器名"><a href="#『重用』容器名" class="headerlink" title="『重用』容器名"></a>『重用』容器名</h3><p>但我们在编写/调试Dockerfile的时候我们经常会重复之前的command，比如这种<code>docker run --name jstorm-zookeeper zookeeper:3.4</code>，然后就容器名就冲突了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker run --name jstorm-zookeeper zookeeper:3.4</div><div class="line">...</div><div class="line">$ docker run --name jstorm-zookeeper zookeeper:3.4</div><div class="line">docker: Error response from daemon: Conflict. The name &quot;/jstorm-zookeeper&quot; is already in use by container xxxxxxxxx</div></pre></td></tr></table></figure></p>
<p>可以在运行 <code>docker run</code> 时候加上<code>--rm</code> flag, 容器将在退出之后销毁。无需手动<code>docker rm CONTAINER</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker run --name jstorm-zookeeper zookeeper:3.4 --rm</div><div class="line"></div><div class="line"># reuse </div><div class="line">$ docker create --name jstorm-zookeeper zookeeper:3.4</div><div class="line">$ docker start jstorm-zookeeper</div><div class="line"></div><div class="line"># no error</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="debug-Dockerfile"><a href="#debug-Dockerfile" class="headerlink" title="debug Dockerfile"></a>debug Dockerfile</h3><p>在写 <code>Dockerfile</code> 的时候，通常并不会一气呵成。有的时候容器启动就crash 直接退出，有的时候build image 就会失败，或者想验证Dockerfile是否符合预期，我们经常要debug Dockerfile。</p>
<p>如果build 失败可以直接 查看stdout的错误信息，拆分指令，重新build。</p>
<h3 id="logs-查看-stdout"><a href="#logs-查看-stdout" class="headerlink" title="logs 查看 stdout"></a><code>logs</code> 查看 stdout</h3><p>所有容器内写到stdout的内容都会被捕获到host中的一个history文件中, 可以通过 <code>docker logs CONTAINER</code> 查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ docker run -d --name jstorm-zookeeper zookeeper:3.4</div><div class="line"></div><div class="line">$ docker logs jstorm-zookeeper</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /conf/zoo.cfg</div><div class="line">2016-12-18 05:55:27,717 [myid:] - INFO  [main:QuorumPeerConfig@124] - Reading configuration from: /conf/zoo.cfg</div><div class="line">2016-12-18 05:55:27,725 [myid:] - INFO  [main:DatadirCleanupManager@78] - autopurge.snapRetainCount set to 3</div><div class="line">2016-12-18 05:55:27,725 [myid:] - INFO  [main:DatadirCleanupManager@79] - autopurge.purgeInterval set to 0</div><div class="line">2016-12-18 05:55:27,726 [myid:] - INFO  [main:DatadirCleanupManager@101] - Purge task is not scheduled.</div><div class="line">2016-12-18 05:55:27,728 [myid:] - WARN  [main:QuorumPeerMain@113] - Either no config or no quorum defined in config, running  in standalone mode</div><div class="line">2016-12-18 05:55:27,746 [myid:] - INFO  [main:QuorumPeerConfig@124] - Reading configuration from: /conf/zoo.cfg</div><div class="line">2016-12-18 05:55:27,747 [myid:] - INFO  [main:ZooKeeperServerMain@96] - Starting server</div><div class="line">2016-12-18 05:55:27,766 [myid:] - INFO  [main:Environment@100] - Server environment:zookeeper.version=3.4.9-1757313, built on 08/23/2016 06:50 GMT</div><div class="line">2016-12-18 05:55:27,766 [myid:] - INFO  [main:Environment@100] - Server environment:host.name=dbc742dd5688</div><div class="line">2016-12-18 05:55:27,767 [myid:] - INFO  [main:Environment@100] - Server environment:java.version=1.8.0_111-internal</div></pre></td></tr></table></figure></p>
<p>即使是容器已经退出的也可以看到，所以可以通过这种方式来分析非预期的退出。这些文件一直保存着，直到通过<code>docker rm</code>把容器删除。文件的具体路径可以通过<code>docker inspect CONTAINER</code> 获得。<br>（然后osx上你并找不到这些文件，因为其实osx的docker实际是运行在”VM”中，具体就不展开了，但是可以通过 <code>screen ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty</code> touch上”VM”的tty）</p>
<p>在使用<code>docker logs</code> 的时候加一些参数来过滤log，默认输出所有log。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Options:</div><div class="line">      --details        Show extra details provided to logs</div><div class="line">  -f, --follow         Follow log output</div><div class="line">      --help           Print usage</div><div class="line">      --since string   Show logs since timestamp</div><div class="line">      --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)</div><div class="line">  -t, --timestamps     Show timestamps</div></pre></td></tr></table></figure></p>
<h3 id="attach-实时查看stdout"><a href="#attach-实时查看stdout" class="headerlink" title="attach 实时查看stdout"></a><code>attach</code> 实时查看stdout</h3><p>如果你想实时查看容器的输出你可以用 <code>docker attach CONTAINER</code> 命令。</p>
<p>默认会绑定stdin，代理signals， 所以如果你 <code>ctrl-c</code> 容器通常会退出。很多时候大家并不想这样，只是想分离开，可以<code>ctrl-p ctrl-q</code>。</p>
<h3 id="执行任意command"><a href="#执行任意command" class="headerlink" title="执行任意command"></a>执行任意command</h3><p>可以通过<code>docker exec CONTAINER COMMAND</code>，来在容器内执行任意 command，比如 cat 一些东西来debug。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ docker run -d --name jstorm-zookeeper zookeeper:3.4</div><div class="line"></div><div class="line">$ docker exec jstorm-zookeeper java -version</div><div class="line">openjdk version &quot;1.8.0_111-internal&quot;</div><div class="line">OpenJDK Runtime Environment (build 1.8.0_111-internal-alpine-r0-b14)</div><div class="line">OpenJDK 64-Bit Server VM (build 25.111-b14, mixed mode)</div></pre></td></tr></table></figure>
<p>也可以直接通过 exec 在容器内启动一个 shell 更方便地调试容器，不必一条条执行<code>docker exec</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker exec -it jstorm-zookeeper /bin/bash</div><div class="line">bash-4.3# pwd</div><div class="line">/zookeeper-3.4.9</div></pre></td></tr></table></figure>
<p><code>docker exec</code> 只能在正在运行的容器上使用，如果已经停止了退出了就不行了，就只好用 <code>docker logs</code> 了。</p>
<h3 id="重写entrypoint和cmd"><a href="#重写entrypoint和cmd" class="headerlink" title="重写entrypoint和cmd"></a>重写<code>entrypoint</code>和<code>cmd</code></h3><p>每个Docker镜像都有 <code>entrypoint</code> 和 <code>cmd</code> , 可以定义在 <code>Dockerfile</code> 中，也可以在运行时指定。这两个概念很容易混淆，而且它们的试用方式也不同。</p>
<p><code>entrypoint</code> 比 <code>cmd</code> 更”高级”，<code>entrypoint</code> 作为容器中pid为1的进程运行（docker不是虚拟机，只是隔离的进程。真正的linux中pid为1的是<code>init</code>）。<br><code>cmd</code> 只是 <code>entrypoint</code>的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</div></pre></td></tr></table></figure>
<p>当我们没有指定 <code>entrypoint</code> 时缺省为 <code>/bin/sh -c</code>。所以其实 <code>entrypoint</code> 是真正表达这个docker应该干什么的，通常大家有一个shell 脚本来代理。<br><code>entrypoint</code> 和 <code>cmd</code> 都可以在运行的时候更改，通过更改来看这样设置<code>entrypoint</code>是否优雅合理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker run -it --name jstorm-zookeeper --entrypoint /bin/bash zookeeper:3.4</div><div class="line">bash-4.3# top</div><div class="line">Mem: 320212K used, 1725368K free, 89112K shrd, 35532K buff, 130532K cached</div><div class="line">CPU:   0% usr   0% sys   0% nic 100% idle   0% io   0% irq   0% sirq</div><div class="line">Load average: 0.20 0.06 0.02 5/195 7</div><div class="line">  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND</div><div class="line">    1     0 root     S     6220   0%   0   0% /bin/bash</div><div class="line">    7     1 root     R     1516   0%   2   0% top</div></pre></td></tr></table></figure>
<p>任何 <code>docker run</code> 命令中在image名后的内容都作为<code>cmd</code>的内容传给 <code>entrypoint</code>当参数。</p>
<h3 id="暂停容器"><a href="#暂停容器" class="headerlink" title="暂停容器"></a>暂停容器</h3><p>使用 <code>docker pause</code> 可以暂停容器中所有进程。这非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">$ docker run -d --name jstorm-zookeeper zookeeper:3.4 &amp;&amp; sleep 0.1 &amp;&amp; docker pause jstorm-zookeeper &amp;&amp; docker logs jstorm-zookeeper</div><div class="line">a24405a53ddd9b7d94d9e77fe2b5a67639a251d681aa2f34fcb0cc96f347ba48</div><div class="line">jstorm-zookeeper</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /conf/zoo.cfg</div><div class="line">2016-12-18 16:17:47,720 [myid:] - INFO  [main:QuorumPeerConfig@124] - Reading configuration from: /conf/zoo.cfg</div><div class="line">2016-12-18 16:17:47,730 [myid:] - INFO  [main:DatadirCleanupManager@78] - autopurge.snapRetainCount set to 3</div><div class="line">2016-12-18 16:17:47,730 [myid:] - INFO  [main:DatadirCleanupManager@79] - autopurge.purgeInterval set to 0</div><div class="line">2016-12-18 16:17:47,730 [myid:] - INFO  [main:DatadirCleanupManager@101] - Purge task is not scheduled.</div><div class="line">2016-12-18 16:17:47,731 [myid:] - WARN  [main:QuorumPeerMain@113] - Either no config or no quorum defined in config, running  in standalone mode</div><div class="line">2016-12-18 16:17:47,757 [myid:] - INFO  [main:QuorumPeerConfig@124] - Reading configuration from: /conf/zoo.cfg</div><div class="line">2016-12-18 16:17:47,757 [myid:] - INFO  [main:ZooKeeperServerMain@96] - Starting server</div><div class="line"></div><div class="line">$ docker unpause jstorm-zookeeper &amp;&amp; docker logs jstorm-zookeeper</div><div class="line">jstorm-zookeeper</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /conf/zoo.cfg</div><div class="line">2016-12-18 16:17:47,720 [myid:] - INFO  [main:QuorumPeerConfig@124] - Reading configuration from: /conf/zoo.cfg</div><div class="line">2016-12-18 16:17:47,730 [myid:] - INFO  [main:DatadirCleanupManager@78] - autopurge.snapRetainCount set to 3</div><div class="line">2016-12-18 16:17:47,730 [myid:] - INFO  [main:DatadirCleanupManager@79] - autopurge.purgeInterval set to 0</div><div class="line">2016-12-18 16:17:47,730 [myid:] - INFO  [main:DatadirCleanupManager@101] - Purge task is not scheduled.</div><div class="line">2016-12-18 16:17:47,731 [myid:] - WARN  [main:QuorumPeerMain@113] - Either no config or no quorum defined in config, running  in standalone mode</div><div class="line">2016-12-18 16:17:47,757 [myid:] - INFO  [main:QuorumPeerConfig@124] - Reading configuration from: /conf/zoo.cfg</div><div class="line">2016-12-18 16:17:47,757 [myid:] - INFO  [main:ZooKeeperServerMain@96] - Starting server</div><div class="line">2016-12-18 16:18:09,039 [myid:] - INFO  [main:Environment@100] - Server environment:zookeeper.version=3.4.9-1757313, built on 08/23/2016 06:50 GMT</div><div class="line">2016-12-18 16:18:09,040 [myid:] - INFO  [main:Environment@100] - Server environment:host.name=a24405a53ddd</div><div class="line">2016-12-18 16:18:09,040 [myid:] - INFO  [main:Environment@100] - Server environment:java.version=1.8.0_111-internal</div><div class="line">2016-12-18 16:18:09,040 [myid:] - INFO  [main:Environment@100] - Server environment:java.vendor=Oracle Corporation</div><div class="line">2016-12-18 16:18:09,040 [myid:] - INFO  [main:Environment@100] - Server environment:java.home=/usr/lib/jvm/java-1.8-openjdk/jre</div><div class="line">2016-12-18 16:18:09,040 [myid:] - INFO  [main:Environment@100] - Server environment:java.class.path=/zookeeper-3.4.9/bin/../build/classes:/zookeeper-3.4.9/bin/../build/lib/*.jar:/zookeeper-3.4.9/bin/../lib/slf4j-log4j12-1.6.1.jar:/zookeeper-3.4.9/bin/../lib/slf4j-api-1.6.1.jar:/zookeeper-3.4.9/bin/../lib/netty-3.10.5.Final.jar:/zookeeper-3.4.9/bin/../lib/log4j-1.2.16.jar:/zookeeper-3.4.9/bin/../lib/jline-0.9.94.jar:/zookeeper-3.4.9/bin/../zookeeper-3.4.9.jar:/zookeeper-3.4.9/bin/../src/java/lib/*.jar:/conf:</div><div class="line">2016-12-18 16:18:09,040 [myid:] - INFO  [main:Environment@100] - Server environment:java.library.path=/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64/server:/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64:/usr/lib/jvm/java-1.8-openjdk/jre/../lib/amd64:/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</div><div class="line">2016-12-18 16:18:09,041 [myid:] - INFO  [main:Environment@100] - Server environment:java.io.tmpdir=/tmp</div><div class="line">2016-12-18 16:18:09,041 [myid:] - INFO  [main:Environment@100] - Server environment:java.compiler=&lt;NA&gt;</div><div class="line">2016-12-18 16:18:09,043 [myid:] - INFO  [main:Environment@100] - Server environment:os.name=Linux</div><div class="line">2016-12-18 16:18:09,043 [myid:] - INFO  [main:Environment@100] - Server environment:os.arch=amd64</div><div class="line">2016-12-18 16:18:09,044 [myid:] - INFO  [main:Environment@100] - Server environment:os.version=4.4.27-moby</div><div class="line">2016-12-18 16:18:09,044 [myid:] - INFO  [main:Environment@100] - Server environment:user.name=zookeeper</div><div class="line">2016-12-18 16:18:09,044 [myid:] - INFO  [main:Environment@100] - Server environment:user.home=/home/zookeeper</div><div class="line">2016-12-18 16:18:09,044 [myid:] - INFO  [main:Environment@100] - Server environment:user.dir=/zookeeper-3.4.9</div><div class="line">2016-12-18 16:18:09,057 [myid:] - INFO  [main:ZooKeeperServer@815] - tickTime set to 2000</div><div class="line">2016-12-18 16:18:09,057 [myid:] - INFO  [main:ZooKeeperServer@824] - minSessionTimeout set to -1</div><div class="line">2016-12-18 16:18:09,058 [myid:] - INFO  [main:ZooKeeperServer@833] - maxSessionTimeout set to -1</div><div class="line">2016-12-18 16:18:09,076 [myid:] - INFO  [main:NIOServerCnxnFactory@89] - binding to port 0.0.0.0/0.0.0.0:2181</div></pre></td></tr></table></figure>
<h3 id="top-和-stats-获得容器中进程的状态"><a href="#top-和-stats-获得容器中进程的状态" class="headerlink" title="top 和 stats 获得容器中进程的状态"></a><code>top</code> 和 <code>stats</code> 获得容器中进程的状态</h3><p><code>docker top CONTAINER</code> 和在容器里执行 <code>top</code> 的效果类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker top jstorm-zookeeper</div><div class="line">PID    USER      TIME  COMMAND</div><div class="line">24593  dockrema  0:01  /usr/lib/jvm/java-1.8-openjdk/jre/bin/java -Dzookeeper.log.dir=. .....</div><div class="line"></div><div class="line">$ docker stats jstorm-zookeeper</div><div class="line">CONTAINER           CPU %     MEM USAGE / LIMIT       MEM %   NET I/O        BLOCK I/O   PIDS</div><div class="line">jstorm-zookeeper    0.00%     24.86 MiB / 1.951 GiB   1.24%   648 B / 648 B  0 B / 0 B   20</div></pre></td></tr></table></figure>
<h3 id="通过-inspect-查看容器的详细信息"><a href="#通过-inspect-查看容器的详细信息" class="headerlink" title="通过 inspect 查看容器的详细信息"></a>通过 <code>inspect</code> 查看容器的详细信息</h3><p><code>docker inspect CONTAINER</code> 饭后镜像和容器的详细信息。比如：</p>
<ul>
<li>State —— 容器的当先状态</li>
<li>LogPath —— history(stdout) file 的路径</li>
<li>Config.Env —— 环境变量</li>
<li>NetworkSettings.Ports —— 端口的映射关系</li>
</ul>
<p>环境变量非常有用很多问题都是环境变量引起的。</p>
<h3 id="history-查看-image-layers"><a href="#history-查看-image-layers" class="headerlink" title="history 查看 image layers"></a><code>history</code> 查看 image layers</h3><p>可以看到各层创建的指令，大小和哈希。可以用来检查这个image是否符合你的预期。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;『重用』容器名&quot;&gt;&lt;a href=&quot;#『重用』容器名&quot; class=&quot;headerlink&quot; title=&quot;『重用』容器名&quot;&gt;&lt;/a&gt;『重用』容器名&lt;/h3&gt;&lt;p&gt;但我们在编写/调试Dockerfile的时候我们经常会重复之前的command，比如这种&lt;code&gt;docker run --name jstorm-zookeeper zookeeper:3.4&lt;/code&gt;，然后就容器名就冲突了。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ docker run --name jstorm-zookeeper zookeeper:3.4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ docker run --name jstorm-zookeeper zookeeper:3.4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;docker: Error response from daemon: Conflict. The name &amp;quot;/jstorm-zookeeper&amp;quot; is already in use by container xxxxxxxxx&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以在运行 &lt;code&gt;docker run&lt;/code&gt; 时候加上&lt;code&gt;--rm&lt;/code&gt; flag, 容器将在退出之后销毁。无需手动&lt;code&gt;docker rm CONTAINER&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ docker run --name jstorm-zookeeper zookeeper:3.4 --rm&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# reuse &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ docker create --name jstorm-zookeeper zookeeper:3.4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ docker start jstorm-zookeeper&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# no error&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="docker" scheme="http://mtunique.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://mtunique.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>如何选择三种Spark API</title>
    <link href="http://mtunique.com/spark_api/"/>
    <id>http://mtunique.com/spark_api/</id>
    <published>2016-11-11T06:30:00.000Z</published>
    <updated>2017-01-07T11:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在<a href="http://www.agildata.com/apache-spark-2-0-api-improvements-rdd-dataframe-dataset-sql/" target="_blank" rel="external">这里</a>查看 Apache Spark 2.0 Api 的改进：RDD，DataFrame，DataSet和SQL</p>
</blockquote>
<p>Apache Spark 正在快速发展，包括更改和添加核心API。最具破坏性的改变之一是dataset。 Spark 1.0 使用RDD API，但是在最近的十二个月引入了两个新不兼容的API。Spark 1.3 引入了完全不同的DataFrame API 而且最近发布的 Spark 1.6 引入了 Dataset API 浏览版。</p>
<p>很多现有的 Spark 开发者想知道是否应该从 RDDs 直接切换到 Dataset API，或者先切换到 DataFrame API。Spark 新手应该选择哪个 API 开始学习。</p>
<p>这篇文章将提供每个API的概述，并且总结了每个的优缺点。 <a href="https://github.com/AgilData/spark-rdd-dataframe-dataset" target="_blank" rel="external">配套的github repo</a>提供了例子，可以从这开始实验文中提到的方法。yd</p>
<p>RDD (弹性分布式数据集) API 从 1.0 开始一直存在 Spark 中。 这个接口和 Java 版本 JavaRDD 对于已经完成标准Spark教程的任何开发人员来说都是熟悉的。从开发人员的角度来看，RDD只是一组表示数据的Java或Scala对象。</p>
<p>RDD API 提供很多转换方法来在数据上执行计算，比如 <code>map()</code> ， <code>filter()</code> ，和 <code>reduce()</code> 。这些方法的结果表示转换后的新RDD。 然而，这些方法只是定义要执行的操作，直到调用action方法才执行转换。action 方法比如是： <code>collect()</code> 和 <code>saveAsObjectFile()</code>.</p>
<a id="more"></a>
<h3 id="RDD-转换和action例子"><a href="#RDD-转换和action例子" class="headerlink" title="RDD 转换和action例子"></a>RDD 转换和action例子</h3><h4 id="Scala"><a href="#Scala" class="headerlink" title="Scala:"></a>Scala:</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rdd.filter(_.age &gt; <span class="number">21</span>)              <span class="comment">// transformation</span></div><div class="line">   .map(_.last)                     <span class="comment">// transformation</span></div><div class="line">   .saveAsObjectFile(<span class="string">"under21.bin"</span>) <span class="comment">// action</span></div></pre></td></tr></table></figure>
<h4 id="java"><a href="#java" class="headerlink" title="java:"></a>java:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rdd.filter(p -&gt; p.getAge() &lt; <span class="number">21</span>)     <span class="comment">// transformation</span></div><div class="line">   .map(p -&gt; p.getLast())            <span class="comment">// transformation</span></div><div class="line">   .saveAsObjectFile(<span class="string">"under21.bin"</span>); <span class="comment">// action</span></div></pre></td></tr></table></figure>
<p>RDD 主要的优势是简单且易于理解，因为他们涉及具体的类，提供了熟悉的面向对象的编程风格，而且编译时类型检查。比如，给定包含Person实例的RDD，我们可以通过引用每个Person对象的age属性来按年龄过滤：</p>
<h3 id="用RDD按属性过滤的例子"><a href="#用RDD按属性过滤的例子" class="headerlink" title="用RDD按属性过滤的例子"></a>用RDD按属性过滤的例子</h3><h4 id="Scala-1"><a href="#Scala-1" class="headerlink" title="Scala:"></a>Scala:</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdd.filter(_.age &gt; <span class="number">21</span>)</div></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java:"></a>Java:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdd.filter(person -&gt; person.getAge() &gt; <span class="number">21</span>)</div></pre></td></tr></table></figure>
<p>RDD主要的劣势是表现不是特别好。每当 Spark 需要在集群中奋发数据或者将数据写入硬盘，默认试用 Java 序列化（尽管在大多数情况下可以试用 Kryo 作为更快的替代方案）。序列化单个 Java 和 Scala 对象的开销是昂贵的而且需要在节点之间传输数据（每个序列化对象包括类的结构和数据）。还有由创建和销毁单个对象导致的垃圾回收的开销。</p>
<h2 id="DataFrame-API"><a href="#DataFrame-API" class="headerlink" title="DataFrame API"></a>DataFrame API</h2><p>Spark 1.3引入了一个新的DataFrame API作为Project Tungsten计划的一部分，旨在提高Spark的性能和可扩展性。 DataFrame API引入了一个模式的概念来描述数据，允许Spark管理模式，并且只在节点之间传递数据，而不是使用Java序列化。在单个进程中执行计算时也有优势，因为Spark可以将数据以二进制格式序列化到堆外存储中，然后直接对此堆外存储器执行许多转换，从而避免为数据集中的每一行构建单个对象造成的垃圾回收成本。 因为Spark理解了模式，所以不需要使用Java序列化来编码数据。</p>
<p>DataFrame API与RDD API截然不同，因为它是一个用于构建关系型查询计划的API，Spark的Catalyst优化器随后可以执行它。 对于熟悉构建查询计划的开发人员来说，这种API非常自然，但对于大多数开发人员来说并不自然。 查询计划可以从字符串中的SQL表达式构建或更函数式的方式构建（通过流式API）。</p>
<h3 id="用DataFrame按属性过滤的例子"><a href="#用DataFrame按属性过滤的例子" class="headerlink" title="用DataFrame按属性过滤的例子"></a>用DataFrame按属性过滤的例子</h3><p><em>请注意，这些示例在Java和Scala中具有相同的语法</em></p>
<h4 id="SQL-风格"><a href="#SQL-风格" class="headerlink" title="SQL 风格"></a>SQL 风格</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.filter(<span class="string">"age &gt; 21"</span>);</div></pre></td></tr></table></figure>
<h4 id="表达式构建器风格"><a href="#表达式构建器风格" class="headerlink" title="表达式构建器风格"></a>表达式构建器风格</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.filter(df.col(<span class="string">"age"</span>).gt(<span class="number">21</span>));</div></pre></td></tr></table></figure>
<p>因为代码按名称引用数据属性，所以编译器不可能捕获任何错误。 如果属性名不正确，那么只有在创建查询计划时才会在运行时检测到错误。</p>
<p>DataFrame API的另一个缺点是它非常以Scala为中心，虽然它支持Java，但支持有限。 例如，从Java对象的现有RDD创建DataFrame时，Spark的Catalyst优化程序无法推断该模式，并假定DataFrame中的任何对象都实现了scala.Product接口。 Scala case类实现了这个接口，因为它们实现了这个接口。</p>
<h2 id="Dataset-API"><a href="#Dataset-API" class="headerlink" title="Dataset API"></a>Dataset API</h2><p>在Spark 1.6中作为API预览发布的Dataset API旨在提供两个方式中最好的部分; 熟悉的面向对象编程风格和RDD API的编译时类型安全性，但具有Catalyst查询优化器的性能优势。 Dataset 也使用与 DataFrame API 相同的高效堆外存储机制。</p>
<p>当涉及序列化数据时，Dataset API具有在JVM表示（对象）和Spark的内部二进制格式之间转换的编码器的概念。 Spark具有内置的编码器，这些编码器非常先进，它们生成字节码以与堆外数据进行交互，并提供对各个属性的按需访问，而不必对整个对象进行反序列化。 Spark还没有提供用于实现自定义编码器的API，但是计划在将来的版本中提供。</p>
<p>此外，Dataset API设计为与Java和Scala同样工作良好。 当使用Java对象时，重要的是它们完全符合bean。在编写本文附带的示例时，当试图从不完全与bean兼容的Java对象列表中创建Java中的Dataset时，我们遇到了错误。</p>
<h3 id="从对象列表创建Dataset"><a href="#从对象列表创建Dataset" class="headerlink" title="从对象列表创建Dataset"></a>从对象列表创建Dataset</h3><h4 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</div><div class="line"><span class="keyword">val</span> sqlContext = <span class="keyword">new</span> <span class="type">SQLContext</span>(sc)</div><div class="line"><span class="keyword">import</span> sqlContext.implicits._</div><div class="line"><span class="keyword">val</span> sampleData: <span class="type">Seq</span>[<span class="type">ScalaPerson</span>] = <span class="type">ScalaData</span>.sampleData()</div><div class="line"><span class="keyword">val</span> dataset = sqlContext.createDataset(sampleData)</div></pre></td></tr></table></figure>
<h4 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(sparkConf);</div><div class="line">SQLContext sqlContext = <span class="keyword">new</span> SQLContext(sc);</div><div class="line">List data = JavaData.sampleData();</div><div class="line">Dataset dataset = sqlContext.createDataset(data, Encoders.bean(JavaPerson.class));</div></pre></td></tr></table></figure>
<p>使用Dataset API的转换看起来非常像RDD API，并且处理Person类，而不是行的抽象。</p>
<h3 id="用Dataset按属性过滤的例子"><a href="#用Dataset按属性过滤的例子" class="headerlink" title="用Dataset按属性过滤的例子"></a>用Dataset按属性过滤的例子</h3><h4 id="Scala-2"><a href="#Scala-2" class="headerlink" title="Scala:"></a>Scala:</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdd.filter(_.age &lt; <span class="number">21</span>)</div></pre></td></tr></table></figure>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java:"></a>Java:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rdd.filter(person -&gt; person.getAge() &lt; <span class="number">21</span>)</div></pre></td></tr></table></figure>
<p>尽管与RDD代码相似，但是该代码正在构建查询计划，而不是处理单个对象，如果age是唯一访问的属性，那么对象的其余数据将不会从堆外存储中读取。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果你是主要在Java开发，那么在采用DataFrame或Dataset API之前，值得考虑移动到Scala。 虽然有努力支持Java，但是Spark是用Scala编写的，使得处理Java对象变得困难（但不是不可能）。</p>
<p>如果你是在用Scala开发，需要你的代码使用Spark 1.6.0生产，那么DataFrame API显然是最稳定的选择，目前提供最好的性能。</p>
<p>但是，Dataset API预览版看起来很有前景，并提供了一种更自然的代码编写方式。 鉴于Spark的快速发展，很可能这个API将在2016年快速成熟，并成为开发新应用的实际API。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.agildata.com/apache-spark-2-0-api-improvements-rdd-dataframe-dataset-sql/&quot;&gt;这里&lt;/a&gt;查看 Apache Spark 2.0 Api 的改进：RDD，DataFrame，DataSet和SQL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Apache Spark 正在快速发展，包括更改和添加核心API。最具破坏性的改变之一是dataset。 Spark 1.0 使用RDD API，但是在最近的十二个月引入了两个新不兼容的API。Spark 1.3 引入了完全不同的DataFrame API 而且最近发布的 Spark 1.6 引入了 Dataset API 浏览版。&lt;/p&gt;
&lt;p&gt;很多现有的 Spark 开发者想知道是否应该从 RDDs 直接切换到 Dataset API，或者先切换到 DataFrame API。Spark 新手应该选择哪个 API 开始学习。&lt;/p&gt;
&lt;p&gt;这篇文章将提供每个API的概述，并且总结了每个的优缺点。 &lt;a href=&quot;https://github.com/AgilData/spark-rdd-dataframe-dataset&quot;&gt;配套的github repo&lt;/a&gt;提供了例子，可以从这开始实验文中提到的方法。yd&lt;/p&gt;
&lt;p&gt;RDD (弹性分布式数据集) API 从 1.0 开始一直存在 Spark 中。 这个接口和 Java 版本 JavaRDD 对于已经完成标准Spark教程的任何开发人员来说都是熟悉的。从开发人员的角度来看，RDD只是一组表示数据的Java或Scala对象。&lt;/p&gt;
&lt;p&gt;RDD API 提供很多转换方法来在数据上执行计算，比如 &lt;code&gt;map()&lt;/code&gt; ， &lt;code&gt;filter()&lt;/code&gt; ，和 &lt;code&gt;reduce()&lt;/code&gt; 。这些方法的结果表示转换后的新RDD。 然而，这些方法只是定义要执行的操作，直到调用action方法才执行转换。action 方法比如是： &lt;code&gt;collect()&lt;/code&gt; 和 &lt;code&gt;saveAsObjectFile()&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="big-data" scheme="http://mtunique.com/categories/big-data/"/>
    
      <category term="spark" scheme="http://mtunique.com/categories/big-data/spark/"/>
    
    
      <category term="big-data" scheme="http://mtunique.com/tags/big-data/"/>
    
      <category term="spark" scheme="http://mtunique.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>python实现各基本数据结构（1）——离散和线性</title>
    <link href="http://mtunique.com/python_datastruct/"/>
    <id>http://mtunique.com/python_datastruct/</id>
    <published>2016-01-27T06:30:00.000Z</published>
    <updated>2016-12-29T16:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="离散"><a href="#离散" class="headerlink" title="离散"></a>离散</h1><h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><table>
<thead>
<tr>
<th style="text-align:left">Operation</th>
<th style="text-align:left">Average case</th>
<th style="text-align:left">Worst Case</th>
<th style="text-align:left">notes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x in s</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Union s</td>
<td style="text-align:left">t</td>
<td style="text-align:left">O(len(s)+len(t))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Intersection s&amp;t</td>
<td style="text-align:left">O(min(len(s), len(t))</td>
<td style="text-align:left">O(len(s) * len(t))</td>
<td style="text-align:left">replace “min” with “max” if t is not a set</td>
</tr>
<tr>
<td style="text-align:left">Multiple intersection s1&amp;s2&amp;..&amp;sn</td>
<td style="text-align:left"></td>
<td style="text-align:left">(n-1)*O(l) where l is max(len(s1),..,len(sn))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Difference s-t</td>
<td style="text-align:left">O(len(s))</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">s.difference_update(t)</td>
<td style="text-align:left">O(len(t))</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Symmetric Difference s^t</td>
<td style="text-align:left">O(len(s))</td>
<td style="text-align:left">O(len(s) * len(t))</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">s.symmetric_difference_update(t)</td>
<td style="text-align:left">O(len(t))</td>
<td style="text-align:left">O(len(t) * len(s))</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><table>
<thead>
<tr>
<th style="text-align:left">Operation</th>
<th style="text-align:left">Average case</th>
<th style="text-align:left">Worst Case</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Copy</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">Get Item</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">Set Item</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">Delete Item</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">Iteration</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
</tr>
</tbody>
</table>
<h2 id="defaultdict（collections-defaultdict）"><a href="#defaultdict（collections-defaultdict）" class="headerlink" title="defaultdict（collections.defaultdict）"></a>defaultdict（collections.defaultdict）</h2><p>defaultdict在处理不存在的key时和dict不同：若某key不存在则用调用default_factory并将其值作为该key的value。例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line">defdict = defaultdict(list)</div><div class="line">defdict[<span class="string">'boo'</span>].append(<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<h1 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="栈（list）"><a href="#栈（list）" class="headerlink" title="栈（list）"></a>栈（list）</h3><table>
<thead>
<tr>
<th style="text-align:left">Operation</th>
<th style="text-align:left">Average Case</th>
<th style="text-align:left">Amortized Worst Case</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Copy</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">Append</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
<tr>
<td style="text-align:left">Insert</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">Get Item</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
<tr>
<td style="text-align:left">Set Item</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
<tr>
<td style="text-align:left">Delete Item</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">Iteration</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">Get Slice</td>
<td style="text-align:left">O(k)</td>
<td style="text-align:left">O(k)</td>
</tr>
<tr>
<td style="text-align:left">Del Slice</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">Set Slice</td>
<td style="text-align:left">O(k+n)</td>
<td style="text-align:left">O(k+n)</td>
</tr>
<tr>
<td style="text-align:left">Extend</td>
<td style="text-align:left">O(k)</td>
<td style="text-align:left">O(k)</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt" target="_blank" rel="external">Sort</a></td>
<td style="text-align:left">O(n log n)</td>
<td style="text-align:left">O(n log n)</td>
</tr>
<tr>
<td style="text-align:left">Multiply</td>
<td style="text-align:left">O(nk)</td>
<td style="text-align:left">O(nk)</td>
</tr>
<tr>
<td style="text-align:left">x in s</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">min(s), max(s)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">Get Length</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
</tbody>
</table>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>相对list它固定了数据类型，可以节约内存。</p>
<h3 id="队列-（Queue，LifoQueue）"><a href="#队列-（Queue，LifoQueue）" class="headerlink" title="队列 （Queue，LifoQueue）"></a>队列 （Queue，LifoQueue）</h3><p>Queue为先进先出（fifo）<br>LifoQueue为后进先出（lifo）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">q = Queue.LifoQueue()</div><div class="line">q.put(<span class="number">1</span>)</div><div class="line">q.put(<span class="number">2</span>)</div><div class="line">q.put(<span class="number">3</span>)</div><div class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</div><div class="line">    <span class="keyword">print</span> q.get(),</div><div class="line"></div><div class="line">q = Queue.Queue()</div><div class="line">q.put(<span class="number">1</span>)</div><div class="line">q.put(<span class="number">2</span>)</div><div class="line">q.put(<span class="number">3</span>)</div><div class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</div><div class="line">    <span class="keyword">print</span> q.get(),</div></pre></td></tr></table></figure>
<p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3 2 1 1 2 3</div></pre></td></tr></table></figure></p>
<h3 id="双向队列-double-ended（collections-deque）"><a href="#双向队列-double-ended（collections-deque）" class="headerlink" title="双向队列 double-ended（collections.deque）"></a>双向队列 double-ended（collections.deque）</h3><p>线程安全，且deque的<code>popleft()</code>, <code>appendleft(item)</code>比list的<code>pop(0)</code>和<code>insert(0, v)</code>要快的多。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Operation</th>
<th style="text-align:left">Average Case</th>
<th style="text-align:left">Amortized Worst Case</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Copy</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
</tr>
<tr>
<td style="text-align:left">append</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
<tr>
<td style="text-align:left">appendleft</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
<tr>
<td style="text-align:left">pop</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
<tr>
<td style="text-align:left">popleft</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
</tr>
<tr>
<td style="text-align:left">extend</td>
<td style="text-align:left">O(k)</td>
<td style="text-align:left">O(k)</td>
</tr>
<tr>
<td style="text-align:left">extendleft</td>
<td style="text-align:left">O(k)</td>
<td style="text-align:left">O(k)</td>
</tr>
<tr>
<td style="text-align:left">rotate</td>
<td style="text-align:left">O(k)</td>
<td style="text-align:left">O(k)</td>
</tr>
<tr>
<td style="text-align:left">remove</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
</tr>
</tbody>
</table>
<h3 id="priority-queue（Queue-PriorityQueue）"><a href="#priority-queue（Queue-PriorityQueue）" class="headerlink" title="priority queue（Queue.PriorityQueue）"></a>priority queue（Queue.PriorityQueue）</h3><p>优先队列是利用 heepq实现的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> PriorityQueue</div><div class="line"></div><div class="line">q = PriorityQueue()</div><div class="line">q.put(<span class="number">2</span>)</div><div class="line">q.put(<span class="number">1</span>)</div><div class="line">q.put(<span class="number">3</span>)</div><div class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</div><div class="line">	<span class="keyword">print</span> q.get(),</div><div class="line"></div><div class="line">q.put((<span class="number">2</span>,<span class="string">'b'</span>))</div><div class="line">q.put((<span class="number">1</span>,<span class="string">'c'</span>))</div><div class="line">q.put((<span class="number">3</span>,<span class="string">'a'</span>))</div><div class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</div><div class="line">    <span class="keyword">print</span> q.get(),</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, priority, v)</span>:</span></div><div class="line">        self.priority = priority</div><div class="line">        self.value = v</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__cmp__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> cmp(self.priority, other.priority)</div><div class="line"></div><div class="line">q.put(A(<span class="number">2</span>, <span class="string">'B'</span>))</div><div class="line">q.put(A(<span class="number">1</span>, <span class="string">'C'</span>))</div><div class="line">q.put(A(<span class="number">3</span>, <span class="string">'A'</span>))</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">not</span> q.empty():</div><div class="line">    next_item = q.get()</div><div class="line">    <span class="keyword">print</span> next_item.value,</div></pre></td></tr></table></figure></p>
<p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1 2 3 (1, &apos;c&apos;) (2, &apos;b&apos;) (3, &apos;a&apos;) C B A</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;离散&quot;&gt;&lt;a href=&quot;#离散&quot; class=&quot;headerlink&quot; title=&quot;离散&quot;&gt;&lt;/a&gt;离散&lt;/h1&gt;&lt;h2 id=&quot;集合（set）&quot;&gt;&lt;a href=&quot;#集合（set）&quot; class=&quot;headerlink&quot; title=&quot;集合（set）&quot;&gt;&lt;/a&gt;集合（set）&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Operation&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Average case&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Worst Case&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;x in s&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(1)&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(n)&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Union s&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;t&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(len(s)+len(t))&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Intersection s&amp;amp;t&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(min(len(s), len(t))&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(len(s) * len(t))&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;replace “min” with “max” if t is not a set&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Multiple intersection s1&amp;amp;s2&amp;amp;..&amp;amp;sn&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;(n-1)*O(l) where l is max(len(s1),..,len(sn))&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Difference s-t&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(len(s))&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;s.difference_update(t)&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(len(t))&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Symmetric Difference s^t&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(len(s))&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(len(s) * len(t))&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;s.symmetric_difference_update(t)&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(len(t))&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;O(len(t) * len(s))&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="python" scheme="http://mtunique.com/categories/python/"/>
    
    
      <category term="python" scheme="http://mtunique.com/tags/python/"/>
    
      <category term="algorithm" scheme="http://mtunique.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>另一个Lambda表达式教程</title>
    <link href="http://mtunique.com/lambda_python/"/>
    <id>http://mtunique.com/lambda_python/</id>
    <published>2015-01-24T06:30:00.000Z</published>
    <updated>2016-12-29T16:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>有很多Python的<a href="http://docs.python.org/tutorial/controlflow.html#lambda-forms" target="_blank" rel="external">lambda</a>教程[1]。最近我偶然发现一个，真挺有用的。是Mike Driscoll在<a href="http://www.blog.pythonlibrary.org/" target="_blank" rel="external">Mouse VS Python</a> 博客上的<a href="http://www.blog.pythonlibrary.org/2010/07/19/the-python-lambda/" target="_blank" rel="external">关于lambda的讨论</a>) 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">当我刚开始学习Python，最容易困惑的概念之一，是lambda语句。我敢肯定，</div><div class="line">其他新的程序员也对它很困惑...</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>Mike的讨论非常好：清晰，直接，且含有实用的示例。它帮助我终于领会了lambda，并导致我写的另一篇lambda教程。</p>
<p>一个用来构造函数的工具 基本上，Python的lambda是用于构造函数（或更精确地说，函数对象）的工具。这意味着，Python有两个构造函数的工具：def和lambda。</p>
<p>下面是一个例子。您可以以正常的方式用def构造一个函数，就像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_root</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> math.sqrt(x)</div></pre></td></tr></table></figure>
<p>或者你可以用lambda</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">square_root = <span class="keyword">lambda</span> x: math.sqrt(x)</div></pre></td></tr></table></figure>
<p>下面是lambda的其他的一些有趣的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sum = <span class="keyword">lambda</span> x, y:   x + y   <span class="comment">#  def sum(x,y): return x + y</span></div><div class="line">out = <span class="keyword">lambda</span>   *x:   sys.stdout.write(<span class="string">" "</span>.join(map(str,x)))</div><div class="line"><span class="keyword">lambda</span> event, name=button8.getLabel(): self.onButton(event, name)</div></pre></td></tr></table></figure>
<p>lambda的好处在哪里？ 已经困扰我有很长一段时间的一个问题是：lambda的好处在哪里？为什么我们需要lambda？</p>
<p>答案是： 我们并不需要lambda，我们不用它一样可以做所有的事情。但是… 在特定的情况下，很是方便 - 它让编写代码更容易一些，而且编写的代码更整洁。</p>
<p>什么样的情况？ 好，其中一个情况是，我们需要一个简单的一次性功能：将被只使用一次函数。</p>
<p>通常，写函数有两个目的：(a)以减少代码重复（b）模块化代码。</p>
<ul>
<li>如果你的应用程序在不同的地方包含重复的代码块，那么你就可以把代码拷贝到一个函数，给函数名，然后 – 使用该函数名 - 在代码中的不同位置调用它。</li>
<li>如果你有一个代码块执行一个明确的操作 - 但真的是冗长、粗糙、破坏程序的可读性，那么你可以把那么长的粗糙的所有代码变成一个函数。</li>
</ul>
<p>但是，假设你需要创建一个函数，将只被使用一次 - 只从应用程序中的一个地方调用。好吧，首先，你不需要给函数的名称。它可以是“匿名的”。而且你可以把它定义在你想使用它的地方。这就是lambda是非常有用的时候。</p>
<p>但是，但是，但是…你会说。</p>
<ul>
<li>首先是，为什么你想要一个只调用一次函数？排除原因（a）。</li>
<li>一个lambda的函数体只能包含单个表达式。这意味着，lambda表达式必须很短。排除了原因（b）。</li>
</ul>
<p>创造一个短的匿名函数可能的原因是什么？</p>
<p>那么，考虑一下代码片段，使用lambda来定义一个Tkinter的GUI界面按钮的行为。 （这个例子是来自Mike的教程。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">frame = tk.Frame(parent)</div><div class="line">frame.pack()</div><div class="line"></div><div class="line">btn22 = tk.Button(frame, </div><div class="line">        text=<span class="string">"22"</span>, command=<span class="keyword">lambda</span>: self.printNum(<span class="number">22</span>))</div><div class="line">btn22.pack(side=tk.LEFT)</div><div class="line"></div><div class="line">btn44 = tk.Button(frame, </div><div class="line">        text=<span class="string">"44"</span>, command=<span class="keyword">lambda</span>: self.printNum(<span class="number">44</span>))</div><div class="line">btn44.pack(side=tk.LEFT)</div></pre></td></tr></table></figure>
<p>这里要记住的一点是，tk.Button需要一个函数对象作为参数传递给该函数的参数。该函数对象将是它（按钮）点击按钮时调用的函数。基本上，该函数指定了点击该按钮时，GUI会做什么。</p>
<p>因此，我们必须通过函数参数传递一个函数对象到一个按钮。并注意 – 因为不同的按钮做不同的事情 - 我们需要为每个按钮对象提供不同的函数对象。每个函数将只使用一次。 所以，尽管我们可以这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent)</span>:</span></div><div class="line">    <span class="string">"""Constructor"""</span></div><div class="line">    frame = tk.Frame(parent)</div><div class="line">    frame.pack()</div><div class="line"></div><div class="line">    btn22 = tk.Button(frame, </div><div class="line">        text=<span class="string">"22"</span>, command=self.buttonCmd22)</div><div class="line">    btn22.pack(side=tk.LEFT)</div><div class="line"></div><div class="line">    btn44 = tk.Button(frame, </div><div class="line">        text=<span class="string">"44"</span>, command=self.buttonCmd44)</div><div class="line">    btn44.pack(side=tk.LEFT)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">buttonCmd22</span><span class="params">(self)</span>:</span></div><div class="line">    self.printNum(<span class="number">22</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">buttonCmd44</span><span class="params">(self)</span>:</span></div><div class="line">    self.printNum(<span class="number">44</span>)</div></pre></td></tr></table></figure>
<p>这样写更容易（且更清楚）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent)</span>:</span></div><div class="line">    <span class="string">"""Constructor"""</span></div><div class="line">    frame = tk.Frame(parent)</div><div class="line">    frame.pack()</div><div class="line"></div><div class="line">    btn22 = tk.Button(frame, </div><div class="line">        text=<span class="string">"22"</span>, command=<span class="keyword">lambda</span>: self.printNum(<span class="number">22</span>))</div><div class="line">    btn22.pack(side=tk.LEFT)</div><div class="line"></div><div class="line">    btn44 = tk.Button(frame, </div><div class="line">        text=<span class="string">"44"</span>, command=<span class="keyword">lambda</span>: self.printNum(<span class="number">44</span>))</div><div class="line">    btn44.pack(side=tk.LEFT)</div></pre></td></tr></table></figure>
<p>当一个GUI程序有这样的代码，该按钮对象需要“call back”到被提供给作为其命令的函数对象。 因此，我们可以说，lambda的最常见的用途之一是在GUI框架，如Tkinter和wxPython中写“回调（callback）”，。</p>
<p>这一切似乎很简单。所以… 为什么lambda如此难以理解？ 我能想到四个原因:</p>
<p>首先Lambda难以理解，因为：一个lambda只能用一个表达式：什么是表达式？</p>
<p>很多人想知道这个问题的答案。如果你在Google上搜索了一下，你会看到很多的帖子，“在Python中，表达式和语句之间的区别是什么？”</p>
<p>一个很好的答案是，表达式返回（或计算结果为）值，而语句则没有。不幸的是，在Python中表达式也可以是一个语句，这种情况很容易造成糊涂。 – 赋值语句就像 A = B = 0，Python支持链式赋值。 （Python不是C）</p>
<p>很多情况下在当人们问这个问题时，他们真正想知道的是：什么样的情况下可以放入lambda，什么情况下不可以？ 而对于这个问题，我觉得遵循一些简单的规则就足够了。</p>
<ul>
<li>如果它不返回一个值，它不是一个表达式，不能放入一个lambda。</li>
<li>如果你能想象它在赋值语句中放在等号的右边，那它是一个表达式，可以放进一个lambda。</li>
</ul>
<p>利用这些规则意味着：</p>
<ol>
<li>赋值语句不能在lambda中使用。在Python中，赋值语句不返回任何东西，甚至没有None（null）。</li>
<li>如数学运算，字符串操作，列表解析等都是一个lambda。</li>
<li>函数调用是表达式。可以在lambda中放置函数调用，并将参数传递给该函数。这样就在一个新的匿名函数中封装了原函数调用（参数其他内容）。</li>
<li>在Python3，print成了一个函数，所以在Python3+，print（…）可以在lambda中使用。</li>
<li>即使函数是返回None，就像在Python3print函数，可以在一个lambda中使用。</li>
<li>[条件表达式]，它是在Python2.5中引入，是表达式（而不是仅仅是一个语法不同的if / else语句）。它们返回一个值，并且可以在一个lambda使用。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lambda</span>: a <span class="keyword">if</span> some_condition() <span class="keyword">else</span> b</div><div class="line"><span class="keyword">lambda</span> x: ‘big’ <span class="keyword">if</span> x &gt; <span class="number">100</span> <span class="keyword">else</span> ‘small’</div></pre></td></tr></table></figure>
<p>难以理解的第二个原因是：一个lambda只有一个表达式：为什么？为什么只有一个？为什么不能多表达式？为什么不能是语句？</p>
<p>对于一些开发人员来说，这个问题的意思是为什么Python的lambda语法如此怪异？对于其他人，尤其是那些有Lisp的背景的，这个问题是指为什么Python的lambda这么残废？为什么不像Lisp的lambda那么强大？</p>
<p>答案是很复杂，它涉及Python语法的“pythonicity”。lambda是一个相对较晚加入Python的。它加入的时候，Python语法已经固定下来了。在这种情况下，语法的lambda必须用“Pythonic”的方式硬塞进一个已经建立好的Python语法中。导致可以在lambda表达式上来完成一些事情有一定的局限性。</p>
<p>坦率地说，我仍然认为lambda语法看起来有点怪异。尽管那样，但是Guido解释了为什么lambda的语法是不会改变的。 Python不会成为Lisp。</p>
<p>难以理解的第三个原因是：：lambda通常被描述为一种工具，用于创建函数，但lambda语句中不含有返回语句。</p>
<p>在某种意义上，return语句隐含在lambda中。lambda规范必须包含只有一个表达式，表达式必须返回一个值，由lambda创建一个匿名函数隐式地返回表达式的返回值。这非常有意义。</p>
<p>还是 - 我想缺乏一个明确的return语句使得很难理解lambda，或者至少很难迅速理解。</p>
<p>难以理解的第四个原因是在lambda教程中通常会用作为创建匿名函数来引入lambda，其实最常见的lambda用途是用于创建匿名过程。</p>
<p>在编程的上古时期，我们就将子程序区分为两种不同的形式：过程和函数。过程是用来做事情的，并没有返回任何东西。函数是用于计算和返回值。函数和过程之间的差异已经成为一些编程语言的一部分了。在Pascal，例如，程序和函数是不同的关键字。</p>
<p>在大多数现代语言中，语言的语法中不再区分过程和函数。 例如Python的函数，可以像过程，函数，或两者兼而有之。（不是完全理想的）结果是一个Python函数总是被称为“函数”，即使它是本质上充当过程。</p>
<p>虽然过程和函数之间的区别已经基本消失的语言结构中，当思考有关程序如何工作的时候我们仍然时常用它。例如，当我读一个程序的源代码，并看到一些函数F，我揣摩F是做什么的。我经常可以把它归类到一个过程或函数 - 我会对自己说“F的目的是做这个的”，或“F的目的是计算和返回等这个和这个的”。</p>
<p>所以现在我想我们可以明白为什么lambda的许多解释是难以理解。 First of all, the Python language itself masks the distinction between a function and a procedure. 首先，Python语言本身模糊了函数和过程的区别。</p>
<p>第二，大多数教程介绍把lambda作为创建匿名函数的工具来介绍，其主要目的是要计算并返回结果。在大多数教程看到（这个包含）的第一个例子展示了如何编写一个lambda来返回值，x的平方根。</p>
<p>但是，这不是lambda最常用的方式，不是当他们在Google上搜索“python lambda教程”的时候要找的。对于lambda最常见的用途是创建匿名的过程，在GUI回调中使用。在这些用例中，我们不关心什么lambda返回什么，我们关心它做了什么。</p>
<p>这就解释了为什么典型的Python程序员难以理解大多数的lambda说明。因为他尝试学习如何编写一些GUI框架的代码：Tkinter，wxPython。运行这些lambda，想理解他们。Google“python lambda教程”。他发现那些以例子开始的教程是完全不适合他。</p>
<p>所以，如果你是这样的程序员 - 本教程是给你写的。我希望它能帮助到你。对不起，我们在本教程的结尾看到了这点，而不是开头。我们希望有一天，有人会写一个lambda教程，而不是以这种方式开头</p>
<ul>
<li>lambda是一个用来构造匿名函数的工具</li>
</ul>
<p>而以这样的句子开始：</p>
<ul>
<li>lambda是一个用来构造回调的工具</li>
</ul>
<p>所以你需要有它。另一个lambda教程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有很多Python的&lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#lambda-forms&quot;&gt;lambda&lt;/a&gt;教程[1]。最近我偶然发现一个，真挺有用的。是Mike Driscoll在&lt;a href=&quot;http://www.blog.pythonlibrary.org/&quot;&gt;Mouse VS Python&lt;/a&gt; 博客上的&lt;a href=&quot;http://www.blog.pythonlibrary.org/2010/07/19/the-python-lambda/&quot;&gt;关于lambda的讨论&lt;/a&gt;) 。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;当我刚开始学习Python，最容易困惑的概念之一，是lambda语句。我敢肯定，&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;其他新的程序员也对它很困惑...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="http://mtunique.com/categories/python/"/>
    
    
      <category term="python" scheme="http://mtunique.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>怎样利用Spark Streaming和Hadoop实现近实时的会话连接</title>
    <link href="http://mtunique.com/spark_streaming_session/"/>
    <id>http://mtunique.com/spark_streaming_session/</id>
    <published>2015-01-06T02:20:00.000Z</published>
    <updated>2016-12-19T07:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个 Spark Streaming 样例是一个可持久化到Hadoop近实时会话的很好的例子。</p>
<p><a href="https://spark.apache.org/streaming" target="_blank" rel="external">Spark Streaming</a> 是Apache Spark 中最有趣的组件之一。你用Spark Streaming可以创建数据管道来用批量加载数据一样的API处理流式数据。此外，Spark Steaming的“micro-batching”方式提供相当好的弹性来应对一些原因造成的任务失败。</p>
<p>在这篇文章中，我将通过网站的事件近实时回话的例子演示使你熟悉一些常见的和高级的Spark Streaming功能，然后加载活动有关的统计数据到Apache HBase，用不喜欢的BI用具来绘图分析。 (<a href="http://en.wikipedia.org/wiki/Sessionization" target="_blank" rel="external">Sessionization</a>指的是捕获的单一访问者的网站会话时间范围内所有点击流活动。)你可以在<a href="https://github.com/tmalaska/SparkStreaming.Sessionization" target="_blank" rel="external">这里</a>找到了这个演示的代码。</p>
<p>像这样的系统对于了解访问者的行为（无论是人还是机器）是超级有用的。通过一些额外的工作它也可以被设计成windowing模式来以异步方式检测可能的欺诈。</p>
<a id="more"></a>
<p>Spark Streaming 代码</p>
<p>我们的例子中的main class是：</p>
<p><code>com.cloudera.sa.example.sparkstreaming.sessionization.SessionizeData</code></p>
<p>让我们来看看这段代码段（忽略1-59行，其中包含imports 和其他无聊的东西）。</p>
<p>60到112行：设置Spark Streaming 这些行是非常基本的，用来设置的Spark Streaming，同时可以选择从HDFS或socket接收数据流。如果你在Spark Streaming方面是一个新手，我已经添加了一些详细的注释帮助理解代码。 （我不打算在这里详谈，因为仍然在样例代码里。）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//This is just creating a Spark Config object.  I don't do much here but</span></div><div class="line"></div><div class="line"><span class="comment">//add the app name.  There are tons of options to put into the Spark config,</span></div><div class="line"></div><div class="line"><span class="comment">//but none are needed for this simple example.</span></div><div class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().</div><div class="line">      setAppName(<span class="string">"SessionizeData "</span> + args(<span class="number">0</span>)).</div><div class="line">      set(<span class="string">"spark.cleaner.ttl"</span>, <span class="string">"120000"</span>)</div><div class="line"></div><div class="line"><span class="comment">//These two lines will get us out SparkContext and our StreamingContext.</span></div><div class="line"></div><div class="line"><span class="comment">//These objects have all the root functionality we need to get started.</span></div><div class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</div><div class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sc, <span class="type">Seconds</span>(<span class="number">10</span>))</div><div class="line"></div><div class="line"><span class="comment">//Here are are loading our HBase Configuration object.  This will have</span></div><div class="line"></div><div class="line"><span class="comment">//all the information needed to connect to our HBase cluster.</span></div><div class="line"></div><div class="line"><span class="comment">//There is nothing different here from when you normally interact with HBase.</span></div><div class="line">    <span class="keyword">val</span> conf = <span class="type">HBaseConfiguration</span>.create();</div><div class="line">    conf.addResource(<span class="keyword">new</span> <span class="type">Path</span>(<span class="string">"/etc/hbase/conf/core-site.xml"</span>));</div><div class="line">    conf.addResource(<span class="keyword">new</span> <span class="type">Path</span>(<span class="string">"/etc/hbase/conf/hbase-site.xml"</span>));</div><div class="line"></div><div class="line"><span class="comment">//This is a HBaseContext object.  This is a nice abstraction that will hide</span></div><div class="line"></div><div class="line"><span class="comment">//any complex HBase stuff from us so we can focus on our business case</span></div><div class="line"></div><div class="line"><span class="comment">//HBaseContext is from the SparkOnHBase project which can be found at</span></div><div class="line"></div><div class="line"><span class="comment">// https://github.com/tmalaska/SparkOnHBase</span></div><div class="line">    <span class="keyword">val</span> hbaseContext = <span class="keyword">new</span> <span class="type">HBaseContext</span>(sc, conf);</div><div class="line"></div><div class="line"><span class="comment">//This is create a reference to our root DStream.  DStreams are like RDDs but</span></div><div class="line"></div><div class="line"><span class="comment">//with the context of being in micro batch world.  I set this to null now</span></div><div class="line"></div><div class="line"><span class="comment">//because I later give the option of populating this data from HDFS or from</span></div><div class="line"></div><div class="line"><span class="comment">//a socket.  There is no reason this could not also be populated by Kafka,</span></div><div class="line"></div><div class="line"><span class="comment">//Flume, MQ system, or anything else.  I just focused on these because</span></div><div class="line"></div><div class="line"><span class="comment">//there are the easiest to set up.</span></div><div class="line">    <span class="keyword">var</span> lines: <span class="type">DStream</span>[<span class="type">String</span>] = <span class="literal">null</span></div><div class="line"></div><div class="line"><span class="comment">//Options for data load.  Will be adding Kafka and Flume at some point</span></div><div class="line">    <span class="keyword">if</span> (args(<span class="number">0</span>).equals(<span class="string">"socket"</span>)) &#123;</div><div class="line">      <span class="keyword">val</span> host = args(<span class="type">FIXED_ARGS</span>);</div><div class="line">      <span class="keyword">val</span> port = args(<span class="type">FIXED_ARGS</span> + <span class="number">1</span>);</div><div class="line"></div><div class="line">      println(<span class="string">"host:"</span> + host)</div><div class="line">      println(<span class="string">"port:"</span> + <span class="type">Integer</span>.parseInt(port))</div><div class="line"></div><div class="line"><span class="comment">//Simple example of how you set up a receiver from a Socket Stream</span></div><div class="line">      lines = ssc.socketTextStream(host, port.toInt)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args(<span class="number">0</span>).equals(<span class="string">"newFile"</span>)) &#123;</div><div class="line"></div><div class="line">      <span class="keyword">val</span> directory = args(<span class="type">FIXED_ARGS</span>)</div><div class="line">      println(<span class="string">"directory:"</span> + directory)</div><div class="line"></div><div class="line"><span class="comment">//Simple example of how you set up a receiver from a HDFS folder</span></div><div class="line">      lines = ssc.fileStream[<span class="type">LongWritable</span>, <span class="type">Text</span>, <span class="type">TextInputFormat</span>](directory, (t: <span class="type">Path</span>) =&amp;gt; <span class="literal">true</span>, <span class="literal">true</span>).map(_._2.toString)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"bad input type"</span>)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>114到124行: 字符串解析 这里是Spark Streaming的开始的地方. 请看下面四行：:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> ipKeyLines = lines.map[(<span class="type">String</span>, (<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>))](eventRecord =&amp;gt; &#123;</div><div class="line"></div><div class="line"><span class="comment">//Get the time and ip address out of the original event</span></div><div class="line">      <span class="keyword">val</span> time = dateFormat.parse(</div><div class="line">        eventRecord.substring(eventRecord.indexOf('[') + <span class="number">1</span>, eventRecord.indexOf(']'))).</div><div class="line">        getTime()</div><div class="line">      <span class="keyword">val</span> ipAddress = eventRecord.substring(<span class="number">0</span>, eventRecord.indexOf(' '))</div><div class="line"></div><div class="line"><span class="comment">//We are return the time twice because we will use the first at the start time</span></div><div class="line"></div><div class="line"><span class="comment">//and the second as the end time</span></div><div class="line">      (ipAddress, (time, time, eventRecord))</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>上面第一命令是在DSTREAM对象“lines”上进行了map函数和，解析原始事件来分离出的IP地址，时间戳和事件的body。对于那些Spark Streaming的新手，一个DSTREAM保存着要处理的一批记录。这些记录由以前所定义的receiver对象填充，并且此map函数在这个micro-batch内产生另一个DSTREAM存储变换后的记录来进行额外的处理。</p>
<p><img src="https://dn-mtunique.qbox.me/sessionization-f11.png" alt="image"></p>
<p>当看像上面的Spark Streaming示意图时，有一些事情要注意：:</p>
<ul>
<li>每个micro-batch在到达构建StreamingContext时设定的那一秒时被销毁</li>
<li>Receiver总是用被下一个micro-batch中的RDDS填充</li>
<li>之前micro batch中老的RDDs将被清理丢弃</li>
</ul>
<p>126到135行：产生Sessions 现在，我们有从网络日志中获得的IP地址和时间，是时候建立sessions了。下面的代码是通过micro-batch内的第一聚集事件建立session，然后在DSTREAM中reduce这些会话。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> latestSessionInfo = ipKeyLines.</div><div class="line">      map[(<span class="type">String</span>, (<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Long</span>))](a =&amp;gt; &#123;</div><div class="line"></div><div class="line"><span class="comment">//transform to (ipAddress, (time, time, counter))</span></div><div class="line">        (a._1, (a._2._1, a._2._2, <span class="number">1</span>))</div><div class="line">      &#125;).</div><div class="line">      reduceByKey((a, b) =&amp;gt; &#123;</div><div class="line"></div><div class="line"><span class="comment">//transform to (ipAddress, (lowestStartTime, MaxFinishTime, sumOfCounter))</span></div><div class="line">        (<span class="type">Math</span>.min(a._1, b._1), <span class="type">Math</span>.max(a._2, b._2), a._3 + b._3)</div><div class="line">      &#125;).</div><div class="line">      updateStateByKey(updateStatbyOfSessions)</div></pre></td></tr></table></figure>
<p>这里有一个关于records如何在micro-batch中被reduce的例子： <img src="https://dn-mtunique.qbox.me/sessionization-table.png" alt="image"></p>
<p>在会话范围内的 micro-batch 内加入，我们可以用超酷的updateStateByKey功能（做join/reduce-like操作）下图说明了就DStreams而言，随着时间变化这个处理过程是怎样的。</p>
<p><img src="https://dn-mtunique.qbox.me/sessionization-f2.png" alt="image"></p>
<p>现在，让我们深入到updateStatbyOfSessions函数，它被定义在文件的底部。此代码（注意详细注释）含有大量的魔法，使sessionization发生在micro-batch的连续模式中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"></div><div class="line">* This function will be called for to union of keys in the Reduce DStream</div><div class="line"></div><div class="line">* with the active sessions from the last micro batch with the ipAddress</div><div class="line"></div><div class="line">* being the key</div><div class="line"></div><div class="line">*</div><div class="line"></div><div class="line">* To goal is that this produces a stateful RDD that has all the active</div><div class="line"></div><div class="line">* sessions.  So we add new sessions and remove sessions that have timed</div><div class="line"></div><div class="line">* out and extend sessions that are still going</div><div class="line"></div><div class="line">*/</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">updateStatbyOfSessions</span></span>(</div><div class="line"></div><div class="line"><span class="comment">//(sessionStartTime, sessionFinishTime, countOfEvents)</span></div><div class="line">      a: <span class="type">Seq</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Long</span>)],</div><div class="line"></div><div class="line"><span class="comment">//(sessionStartTime, sessionFinishTime, countOfEvents, isNewSession)</span></div><div class="line">      b: <span class="type">Option</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Boolean</span>)]</div><div class="line">    ): <span class="type">Option</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Boolean</span>)] = &#123;</div><div class="line"></div><div class="line"><span class="comment">//This function will return a Optional value.</span></div><div class="line"></div><div class="line"><span class="comment">//If we want to delete the value we can return a optional "None".</span></div><div class="line"></div><div class="line"><span class="comment">//This value contains four parts</span></div><div class="line"></div><div class="line"><span class="comment">//(startTime, endTime, countOfEvents, isNewSession)</span></div><div class="line">    <span class="keyword">var</span> result: <span class="type">Option</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Long</span>, <span class="type">Boolean</span>)] = <span class="literal">null</span></div><div class="line"></div><div class="line"><span class="comment">// These if statements are saying if we didn't get a new event for</span></div><div class="line"></div><div class="line"><span class="comment">//this session's ip address for longer then the session</span></div><div class="line"></div><div class="line"><span class="comment">//timeout + the batch time then it is safe to remove this key value</span></div><div class="line"></div><div class="line"><span class="comment">//from the future Stateful DStream</span></div><div class="line">    <span class="keyword">if</span> (a.size == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="type">System</span>.currentTimeMillis() - b.get._2 &amp;gt; <span class="type">SESSION_TIMEOUT</span> + <span class="number">11000</span>) &#123;</div><div class="line">        result = <span class="type">None</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (b.get._4 == <span class="literal">false</span>) &#123;</div><div class="line">          result = b</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          result = <span class="type">Some</span>((b.get._1, b.get._2, b.get._3, <span class="literal">false</span>))</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//Now because we used the reduce function before this function we are</span></div><div class="line"></div><div class="line"><span class="comment">//only ever going to get at most one event in the Sequence.</span></div><div class="line">    a.foreach(c =&amp;gt; &#123;</div><div class="line">      <span class="keyword">if</span> (b.isEmpty) &#123;</div><div class="line"></div><div class="line"><span class="comment">//If there was no value in the Stateful DStream then just add it</span></div><div class="line"></div><div class="line"><span class="comment">//new, with a true for being a new session</span></div><div class="line">        result = <span class="type">Some</span>((c._1, c._2, c._3, <span class="literal">true</span>))</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (c._1 - b.get._2 &amp;lt; <span class="type">SESSION_TIMEOUT</span>) &#123;</div><div class="line"></div><div class="line"><span class="comment">//If the session from the stateful DStream has not timed out</span></div><div class="line"></div><div class="line"><span class="comment">//then extend the session</span></div><div class="line">          result = <span class="type">Some</span>((</div><div class="line">              <span class="type">Math</span>.min(c._1, b.get._1),</div><div class="line"><span class="comment">//newStartTime</span></div><div class="line">              <span class="type">Math</span>.max(c._2, b.get._2),</div><div class="line"><span class="comment">//newFinishTime</span></div><div class="line">              b.get._3 + c._3,</div><div class="line"><span class="comment">//newSumOfEvents</span></div><div class="line">              <span class="literal">false</span></div><div class="line"><span class="comment">//This is not a new session</span></div><div class="line">            ))</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line"><span class="comment">//Otherwise remove the old session with a new one</span></div><div class="line">          result = <span class="type">Some</span>((</div><div class="line">              c._1,</div><div class="line"><span class="comment">//newStartTime</span></div><div class="line">              c._2,</div><div class="line"><span class="comment">//newFinishTime</span></div><div class="line">              b.get._3,</div><div class="line"><span class="comment">//newSumOfEvents</span></div><div class="line">              <span class="literal">true</span></div><div class="line"><span class="comment">//new session</span></div><div class="line">            ))</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">    result</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这段代码做了很多事，而且通过很多方式，这是整个工作中最复杂的部分。总之，它跟踪活动的会话，所以你知道你是继续现有的会话还是启动一个新的。</p>
<p>126到207行：计数和HBase 这部分做了大多数计数工作。在这里有很多是重复的，让我们只看一个count的例子，然后一步步地我们把生成的同一个记录counts存储在HBase中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> onlyActiveSessions = latestSessionInfo.filter(t =&amp;gt; <span class="type">System</span>.currentTimeMillis() - t._2._2 &amp;lt; <span class="type">SESSION_TIMEOUT</span>)</div><div class="line">…</div><div class="line"><span class="keyword">val</span> newSessionCount = onlyActiveSessions.filter(t =&amp;gt; &#123;</div><div class="line"></div><div class="line"><span class="comment">//is the session newer then that last micro batch</span></div><div class="line"></div><div class="line"><span class="comment">//and is the boolean saying this is a new session true</span></div><div class="line">        (<span class="type">System</span>.currentTimeMillis() - t._2._2 &amp;gt; <span class="number">11000</span> &amp;amp;&amp;amp; t._2._4)</div><div class="line">      &#125;).</div><div class="line">      count.</div><div class="line">      map[<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Long</span>]](t =&amp;gt; <span class="type">HashMap</span>((<span class="type">NEW_SESSION_COUNTS</span>, t)))</div></pre></td></tr></table></figure>
<p>总之，上面的代码是过滤除了活动的会话其他所有会话，对他们进行计数，并把该最终计记录到一个的HashMap实例中。它使用HashMap作为容器，所以在所有的count做完后，我们可以调用下面的reduce函数把他们都到一个单一的记录。 （我敢肯定有更好的方法来实现这一点，但这种方法工作得很好。）</p>
<p>接下来，下面的代码处理所有的那些HashMap，并把他们所有的值在一个HashMap中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> allCounts = newSessionCount.</div><div class="line">      union(totalSessionCount).</div><div class="line">      union(totals).</div><div class="line">      union(totalEventsCount).</div><div class="line">      union(deadSessionsCount).</div><div class="line">      union(totalSessionEventCount).</div><div class="line">      reduce((a, b) =&amp;gt; b ++ a)</div></pre></td></tr></table></figure>
<p>用HBaseContext来使Spark Streaming与HBase交互超级简单。所有你需要做的就是用HashMap和函数将其转换为一个put对象提供给DSTREAM。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">hbaseContext.streamBulkPut[<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Long</span>]](</div><div class="line">      allCounts,</div><div class="line"><span class="comment">//The input RDD</span></div><div class="line">      hTableName,</div><div class="line"><span class="comment">//The name of the table we want to put too</span></div><div class="line">      (t) =&amp;gt; &#123;</div><div class="line"></div><div class="line"><span class="comment">//Here we are converting our input record into a put</span></div><div class="line"></div><div class="line"><span class="comment">//The rowKey is C for Count and a backward counting time so the newest</span></div><div class="line"></div><div class="line"><span class="comment">//count show up first in HBase's sorted order</span></div><div class="line">        <span class="keyword">val</span> put = <span class="keyword">new</span> <span class="type">Put</span>(<span class="type">Bytes</span>.toBytes(<span class="string">"C."</span> + (<span class="type">Long</span>.<span class="type">MaxValue</span> - <span class="type">System</span>.currentTimeMillis())))</div><div class="line"></div><div class="line"><span class="comment">//We are iterating through the HashMap to make all the columns with their counts</span></div><div class="line">        t.foreach(kv =&amp;gt; put.add(<span class="type">Bytes</span>.toBytes(hFamily), <span class="type">Bytes</span>.toBytes(kv._1), <span class="type">Bytes</span>.toBytes(kv._2.toString)))</div><div class="line">        put</div><div class="line">      &#125;,</div><div class="line">      <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<p>现在，HBase的这些信息可以用Apache Hive table包起来，然后通过你喜欢的BI工具执行一个查询来获取像下面这样的图，它每次micro-batch会刷新。 <img src="https://dn-mtunique.qbox.me/sessionization-f3.png" alt="image"></p>
<p>209到215行：写入HDFS 最后的任务是把拥有事件数据的活动会话信息加入，然后把事件以会话的开始时间来持久化到HDFS。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//Persist to HDFS</div><div class="line">ipKeyLines.join(onlyActiveSessions).</div><div class="line">  map(t =&amp;gt; &#123;</div><div class="line"></div><div class="line">//Session root start time | Event message</div><div class="line">    dateFormat.format(new Date(t._2._2._1)) + &quot;t&quot; + t._2._1._3</div><div class="line">  &#125;).</div><div class="line">  saveAsTextFiles(outputDir + &quot;/session&quot;, &quot;txt&quot;)</div></pre></td></tr></table></figure></p>
<p>结论</p>
<p>我希望你跳出这个例子 来走像了很多工作，感觉与代码只是一点点做，因为它是。想象一下你还可以用这种模式和Spark Streaming与HBase HDFS很容易交互的这种能力做什么东西。</p>
<p><a href="http://blog.cloudera.com/blog/2014/11/how-to-do-near-real-time-sessionization-with-spark-streaming-and-apache-hadoop/" target="_blank" rel="external">原文</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个 Spark Streaming 样例是一个可持久化到Hadoop近实时会话的很好的例子。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spark.apache.org/streaming&quot;&gt;Spark Streaming&lt;/a&gt; 是Apache Spark 中最有趣的组件之一。你用Spark Streaming可以创建数据管道来用批量加载数据一样的API处理流式数据。此外，Spark Steaming的“micro-batching”方式提供相当好的弹性来应对一些原因造成的任务失败。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我将通过网站的事件近实时回话的例子演示使你熟悉一些常见的和高级的Spark Streaming功能，然后加载活动有关的统计数据到Apache HBase，用不喜欢的BI用具来绘图分析。 (&lt;a href=&quot;http://en.wikipedia.org/wiki/Sessionization&quot;&gt;Sessionization&lt;/a&gt;指的是捕获的单一访问者的网站会话时间范围内所有点击流活动。)你可以在&lt;a href=&quot;https://github.com/tmalaska/SparkStreaming.Sessionization&quot;&gt;这里&lt;/a&gt;找到了这个演示的代码。&lt;/p&gt;
&lt;p&gt;像这样的系统对于了解访问者的行为（无论是人还是机器）是超级有用的。通过一些额外的工作它也可以被设计成windowing模式来以异步方式检测可能的欺诈。&lt;/p&gt;
    
    </summary>
    
      <category term="big-data" scheme="http://mtunique.com/categories/big-data/"/>
    
      <category term="spark" scheme="http://mtunique.com/categories/big-data/spark/"/>
    
    
      <category term="big-data" scheme="http://mtunique.com/tags/big-data/"/>
    
      <category term="spark" scheme="http://mtunique.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>Linux下用户空间调试工具</title>
    <link href="http://mtunique.com/linux_userspace/"/>
    <id>http://mtunique.com/linux_userspace/</id>
    <published>2014-12-29T09:51:00.000Z</published>
    <updated>2016-12-29T16:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据定义，调试工具是那些那些使我们能够监测、控制和纠正其他程序的程序。我们为什么应该用调试工具呢? 在有些情况下，运行一些程序的时候我们会被卡住，我们需要明白究竟发生了什么。 例如, 我们正在运行应用程序，它产生了一些错误消息。要修复这些错误，我们应该先找出为什么产生这些错误的消息和这些错误消息从哪里产生的。 一个应用程序可能突然挂起，我们必须了解其他什么进程同时在运行。我们可能还必须弄清楚进程<code>x</code>挂起的时候在做什么。为了剖析这些细节， 我们需要调试工具的帮助。有几个Linux下的用户空间调试工具和技术，他们用来分析用户空间问题相当有用。他们是:</p>
<ul>
<li><code>print</code>语句</li>
<li>查询 (/proc, /sys etc)</li>
<li>跟踪 (strace/ltrace)</li>
<li>Valgrind (memwatch)</li>
<li>GDB</li>
</ul>
<p>让我们一个个地了解。<br><a id="more"></a></p>
<h3 id="1-print语句"><a href="#1-print语句" class="headerlink" title="1.print语句"></a>1.<code>print</code>语句</h3><p>这是一个基本的原始的调试问题的方法。 我们可以在程序中插入print语句来了解控制流和变量值。 虽然这是一个简单的技术, 但它有一些缺点的。 程序需要进行编辑以添加<code>print</code>语句，然后不得不重新编译，重新运行来获得输出。 如果要调试的程序相当大，这是一个耗时的方法。</p>
<h3 id="2-查询"><a href="#2-查询" class="headerlink" title="2. 查询"></a>2. 查询</h3><p>在某些情况下，我们需要弄清楚在一个运行在内核中的进程的状态和内存映射。为了获得这些信息，我们不需要在内核中插入任何代码。 相反，可以用 /proc 文件系统。</p>
<p>/proc 是一个伪文件系统，系统一起启动运行就收集着运行时系统的信息 (cpu信息, 内存容量 等)。</p>
<p><img src="https://dn-mtunique.qbox.me/proc-output.png" alt="output of ls /proc"> <code>ls /proc</code>的输出</p>
<p>正如你看到的, 系统中运行的每一个进程在/proc文件系统中有一个以进程id命名的项。每个进程的细节信息可以在进程id对应的目录下的文件中获得。</p>
<p><img src="https://dn-mtunique.qbox.me/proc-pid.png" alt="output of ls /proc/pid"> <code>ls /proc/pid</code>的输出</p>
<p>解释/proc文件系统内的所有条目超出了本文的范围。一些有用的列举如下：</p>
<ul>
<li>/proc/cmdline -&gt; 内核命令行</li>
<li>/proc/cpuinfo -&gt; 关于处理器的品牌，型号信息等</li>
<li>/proc/filesystems -&gt; 文件系统的内核支持的信息</li>
<li>/proc//cmdline -&gt; 命令行参数传递到当前进程</li>
<li>/proc//mem -&gt; 当前进程持有的内存</li>
<li>/proc//status -&gt; 当前进程的状态</li>
</ul>
<h3 id="3-跟踪"><a href="#3-跟踪" class="headerlink" title="3. 跟踪"></a>3. 跟踪</h3><p>strace的和ltrace是两个在Linux中用来追踪程序的执行细节的跟踪工具</p>
<h4 id="strace"><a href="#strace" class="headerlink" title="strace:"></a>strace:</h4><p>strace拦截和记录系统调用并且由它来接收的信号。对于用户，它显示了系统调用，传递给它们的参数和返回值。 strace的可以附着到已在运行的进程中，或到一个新的进程。它作为一个针对开发者和系统管理员的诊断，调试工具是很有用的。它也可以用来当为一个通过跟踪不同的程序调用来了解系统的工具。这个工具的好处是不需要源代码和程序不需要重新编译。</p>
<p>使用strace的基本语法是：</p>
<p>strace command</p>
<p>strace有各种各样的参数。可以检查看strace的手册页来获得更多的细节。</p>
<p>strace的输出非常长，我们通常不会对显示的每一行都感兴趣。我们可以用<code>-e expr</code>选项来过滤不想要的数据。</p>
<p>用 <code>-p pid</code> 选项来绑到运行中的进程.</p>
<p>用<code>-o</code>选项，命令的输出可以被重定向到文件。</p>
<p><img src="https://dn-mtunique.qbox.me/strace-output.png" alt="output of strace filtering only the open system call"> strace过滤成只有系统调用的输出</p>
<h4 id="ltrace"><a href="#ltrace" class="headerlink" title="ltrace:"></a>ltrace:</h4><p>ltrace跟踪和记录一个进程的动态（运行时）库的调用和收到的信号。它也可以跟踪一个进程所作的系统调用。它的用法是类似与strace。</p>
<p>ltrace command</p>
<p><code>-i</code> 选项在调用库时打印指令指针。</p>
<p><code>-S</code> 选项被用来现实系统调用和库调用</p>
<p>所有可用的选项请参阅ltrace手册。</p>
<p><img src="https://dn-mtunique.qbox.me/ltrace-output.png" alt="output of ltrace capturing strcmp library call"> ltrace捕捉<code>STRCMP</code>库调用的输出</p>
<h3 id="4-Valgrind"><a href="#4-Valgrind" class="headerlink" title="4. Valgrind"></a>4. Valgrind</h3><p>Valgrind是一套调试和分析工具。一个被广泛使用的工具，默认的工具被称为<code>Memcheck</code>的拦截malloc()，new()，free()和delete()调用的内存检测工具。换句话说，它在检测下面这些问题非常有用：</p>
<ul>
<li>内存泄露</li>
<li>重释放</li>
<li>访问越界</li>
<li>使用未初始化的内存</li>
<li>使用的内存已经被释放 等。</li>
</ul>
<p>它直接通过可执行文件运行。</p>
<p>Valgrind带有一些缺点。因为它增加了内存占用，可以减慢你的程序。它有时会造成误报和漏报。它不能检测出静态分配的数组的访问越界问题。</p>
<p>为了用他， 首先下载并安装在你的系统上。 (<a href="http://valgrind.org/downloads.html" target="_blank" rel="external">Valgrind下载页面</a>). 可以使用操作系统上的包管理起来安装。</p>
<p>使用命令行安装涉及解压缩，解包下载的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -xjvf valgring-x.y.z.tar.bz2 (where x.y.z is the version number you are trying to install)</div></pre></td></tr></table></figure>
<p>进入新创建的目录（的valgrind-XYZ）内运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>让我们通过一个小程序(test.c)来理解valgrind怎么工作的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> x = <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"></div><div class="line">x[<span class="number">10</span>] = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">f();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -o test -g test.c</div></pre></td></tr></table></figure>
<p>现在我们有一个可执行文件叫做<code>test</code>。我们现在可以用valgrind来检测内存错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">valgrind –tool=memcheck –leak-check=yes test</div></pre></td></tr></table></figure>
<p>这是valgrind呈现错误的输出：</p>
<p><img src="https://dn-mtunique.qbox.me/Valgrind.png" alt="output of valgrind showing heap block overrun and memory leak"> valgrind显示堆溢出和内存泄漏的输出</p>
<p>正如我们在上面看到的消息，我们正在试图访问超出函数f分配的内存和分配的内存没有释放。</p>
<h3 id="5-GDB"><a href="#5-GDB" class="headerlink" title="5. GDB"></a>5. GDB</h3><p>GDB是来自自由软件基金会的调试器。它对定位和修复代码中的问题很有帮助。当被调试的程序运行时，它给用户控制权去执行各种动作， 比如:</p>
<ul>
<li>启动程序</li>
<li>停在指定位置</li>
<li>停在指定的条件</li>
<li>检查所需信息</li>
<li>改变程序中的数据 等。</li>
</ul>
<p>你也可以附加一个崩溃的程序coredump到GDB并分析故障的原因。</p>
<p>GDB提供很多选项来调试程序。 然而，我们将介绍一些重要的选择，来感受如何开始使用GDB。</p>
<p>如果你还没有安装GDB，可以在这里下载 <a href="http://www.gnu.org/software/gdb/download/" target="_blank" rel="external">GDB官方网站</a>.</p>
<h4 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序:"></a>编译程序:</h4><p>为了用GDB调试程序，必须使用gcc的<code>-g</code>选项进行编译。将以操作系统的本地格式产生调试信息，GDB利用这些信息来工作。</p>
<p>下面是一个简单的程序（example1.c）执行被零除用来显示GDB的用法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> x=<span class="number">5</span>, y=<span class="number">0</span>;</div><div class="line"><span class="keyword">return</span> x / y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">divide();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://dn-mtunique.qbox.me/gdb-example.png" alt="An example showing usage of gdb"> 展示GDB用法的例子</p>
<h4 id="调用-GDB"><a href="#调用-GDB" class="headerlink" title="调用 GDB:"></a>调用 GDB:</h4><p>通过在命令行中执行<code>gdb</code>来启动gdb:</p>
<p><img src="https://dn-mtunique.qbox.me/gdb.png" alt="invoking gdb"> 调用 gdb</p>
<p>一旦调用, 它将等待终端命令并执行，直到退出。</p>
<p>如果一个进程已经在运行，你需要将GDB连接到它上面，可以通过指定进程ID来实现。假设程序已经崩溃，要分析问题的原因，则连接GDB到core文件。</p>
<h4 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序:"></a>启动程序:</h4><p>一旦你在GDB里面，使用<code>run</code>命令来启动程序进行调试。</p>
<h4 id="给程序传参数"><a href="#给程序传参数" class="headerlink" title="给程序传参数:"></a>给程序传参数:</h4><p>使用<code>set args</code>给你的程序传参数，当程序下次运行时将获得参数。<code>show args</code>将显示传递给程序的参数。</p>
<h4 id="检查堆栈"><a href="#检查堆栈" class="headerlink" title="检查堆栈:"></a>检查堆栈:</h4><p>每当程序停止，任何人想明白的第一件事就是它为什么停止，以及怎么停在那里的。该信息被称为反向跟踪。由程序产生每个函数调用和局部变量，传递的参数，调用位置等信息一起存储在堆栈内的数据块种，被称为一帧。我们可以使用GDB来检查所有这些数据。GDB从最底层的帧开始给这些帧编号。</p>
<ul>
<li>bt: 打印整个堆栈的回溯</li>
<li>bt  打印n个帧的回溯</li>
<li>frame : 切换到指定的帧，并打印该帧</li>
<li>up : 上移<code>n</code>个帧</li>
<li>down : 下移<code>n</code>个帧 ( n默认是1)</li>
</ul>
<h4 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据:"></a>检查数据:</h4><p>程序的数据可以在里面GDB使用<code>print</code>命令进行检查。例如，如果<code>X</code>是调试程序内的变量，<code>print x</code>会打印x的值。</p>
<h4 id="检查源码"><a href="#检查源码" class="headerlink" title="检查源码:"></a>检查源码:</h4><p>源码可以在GDB中打印。默认情况下，<code>list</code>命令会打印10行代码。</p>
<ul>
<li>list : 列出<code>linenum</code>行周外的源码</li>
<li>list : 从<code>function</code>开始列出源码</li>
<li>disas : 显示该函数机器代码</li>
</ul>
<h4 id="停止和恢复程序"><a href="#停止和恢复程序" class="headerlink" title="停止和恢复程序:"></a>停止和恢复程序:</h4><p>使用GDB，我们可以在必要的地方设置断点，观察点等来停止程序。</p>
<ul>
<li>break : 在<code>location</code>设置一个断点。当在程序执行到这里时断点将被击中，控制权被交给用户。</li>
<li>watch : 当<code>expr</code>被程序写而且它的值发生变化时GDB将停止</li>
<li>catch : 当<code>event</code>发生时GDB停止。</li>
<li>disable : 禁用指定断点</li>
<li>enable : 启用指定断点</li>
<li>delete : 删除 断点/观察点/捕获点。 如果没有传递参数默认操作是在所有的断点。</li>
<li>step: 一步一步执行程序</li>
<li>continue: 继续执行程序，直到执行完毕</li>
</ul>
<h4 id="退出-GDB"><a href="#退出-GDB" class="headerlink" title="退出 GDB:"></a>退出 GDB:</h4><p>用<code>quit</code>命令还从GDB中退出。</p>
<p>GDB还有更多的可用选项。里面GDB使用help选项了解更多详情。</p>
<p><img src="https://dn-mtunique.qbox.me/gdb-help.png" alt="getting help within gdb"> 在GDB种获得帮助</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这篇文章中，我们已经看到不同类型的Linux用户空间的调试工具。总结以上所有内容，这是些什么时候使用该什么的快速指南：</p>
<p>基本调试，获得关键变量 - print 语句</p>
<p>获取有关文件系统支持，可用内存，CPU，运行程序的内核状态等信息 - 查询 /proc 文件系统</p>
<p>最初的问题诊断，系统调用或库调用的相关问题，了解程序流程 – strace / ltrace</p>
<p>应用程序内存空间的问题 – valgrind</p>
<p>检查应用程序运行时的行为，分析应用程序崩溃 – gdb。</p>
<hr>
<p>via: <a href="http://linoxide.com/linux-how-to/user-space-debugging-tools-linux/" target="_blank" rel="external">http://linoxide.com/linux-how-to/user-space-debugging-tools-linux/</a></p>
<p>作者：<a href="http://linoxide.com/author/bnpoornima/" target="_blank" rel="external">B N Poornima</a> 译者：<a href="https://github.com/mtunique" target="_blank" rel="external">mtunique</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据定义，调试工具是那些那些使我们能够监测、控制和纠正其他程序的程序。我们为什么应该用调试工具呢? 在有些情况下，运行一些程序的时候我们会被卡住，我们需要明白究竟发生了什么。 例如, 我们正在运行应用程序，它产生了一些错误消息。要修复这些错误，我们应该先找出为什么产生这些错误的消息和这些错误消息从哪里产生的。 一个应用程序可能突然挂起，我们必须了解其他什么进程同时在运行。我们可能还必须弄清楚进程&lt;code&gt;x&lt;/code&gt;挂起的时候在做什么。为了剖析这些细节， 我们需要调试工具的帮助。有几个Linux下的用户空间调试工具和技术，他们用来分析用户空间问题相当有用。他们是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;print&lt;/code&gt;语句&lt;/li&gt;
&lt;li&gt;查询 (/proc, /sys etc)&lt;/li&gt;
&lt;li&gt;跟踪 (strace/ltrace)&lt;/li&gt;
&lt;li&gt;Valgrind (memwatch)&lt;/li&gt;
&lt;li&gt;GDB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们一个个地了解。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://mtunique.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://mtunique.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【Spark笔记】基本概念</title>
    <link href="http://mtunique.com/spark_base/"/>
    <id>http://mtunique.com/spark_base/</id>
    <published>2014-11-28T05:30:00.000Z</published>
    <updated>2016-12-19T07:06:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码量"><a href="#代码量" class="headerlink" title="代码量"></a>代码量</h2><p>Spark: 20,000 LOC</p>
<p>Hadoop 1.0: 90,000 LOC</p>
<p>Hadoop 2.0: 220,000 LOC</p>
<p><img src="https://dn-mtunique.qbox.me/sparkCodeSize.png" alt="pic"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>RDD</code> - resillient distributed dataset 弹性分布式数据集</p>
<p><code>Operation</code> - 作用于RDD的各种操作分为transformation和action</p>
<p><code>Job</code> - 作业，一个JOB包含多个RDD及作用于相应RDD上的各种operation</p>
<p><code>Stage</code> - 一个作业分为多个阶段</p>
<p><code>Partition</code> - 数据分区， 一个RDD中的数据可以分成多个不同的区</p>
<p><code>DAG</code> - Directed Acycle graph, 有向无环图，反应RDD之间的依赖关系</p>
<p><code>Narrow dependency</code> - 窄依赖，子RDD依赖于父RDD中固定的data partition</p>
<p><code>Wide Dependency</code> - 宽依赖，子RDD对父RDD中的所有data partition都有依赖</p>
<p><code>Caching Managenment</code> - 缓存管理，对RDD的中间计算结果进行缓存管理以加快整体的处理速度<br><a id="more"></a></p>
<p>这些基本概念会反复提到</p>
<h2 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h2><p>Spark应用程序可分两部分：driver部分和executor部分初始化SparkContext和主体程序</p>
<h3 id="A：driver部分"><a href="#A：driver部分" class="headerlink" title="A：driver部分"></a>A：driver部分</h3><p>driver部分主要是对SparkContext进行配置、初始化以及关闭。初始化SparkContext是为了构建Spark应用程序的运行环境，在初始化SparkContext，要先导入一些Spark的类和隐式转换；在executor部分运行完毕后，需要将SparkContext关闭。</p>
<h3 id="B：executor部分"><a href="#B：executor部分" class="headerlink" title="B：executor部分"></a>B：executor部分</h3><p>Spark应用程序的executor部分是对数据的处理，数据分三种：</p>
<h4 id="原生数据"><a href="#原生数据" class="headerlink" title="原生数据"></a>原生数据</h4><blockquote><p>包含输入的数据和输出的数据。</p>
</blockquote>
<h5 id="输入原生数据"><a href="#输入原生数据" class="headerlink" title="输入原生数据"></a>输入原生数据</h5><ol>
<li>scala集合数据集，如Array(1,2,3,4,5)，Spark使用parallelize方法转换成RDD。</li>
<li>hadoop数据集，Spark支持存储在hadoop上的文件和hadoop支持的其他文件系统，如本地文件、HBase、SequenceFile和Hadoop的输入格式。例如Spark使用txtFile方法可以将本地文件或HDFS文件转换成RDD.</li>
</ol>
<h5 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h5><ol>
<li>生成Scala标量数据，如count（返回RDD中元素的个数）、reduce、fold/aggregate；返回几个标量，如take（返回前几个元素）。</li>
<li>生成Scala集合数据集，如collect（把RDD中的所有元素倒入 Scala集合类型）、lookup（查找对应key的所有值）。</li>
<li>生成hadoop数据集，如saveAsTextFile、saveAsSequenceFile</li>
</ol>
<h4 id="RDD-Resilient-Distributed-Datasets"><a href="#RDD-Resilient-Distributed-Datasets" class="headerlink" title="RDD(Resilient Distributed Datasets)"></a>RDD(Resilient Distributed Datasets)</h4><blockquote><p>是一个容错的、并行的数据结构，可以让用户显式地将数据存储到磁盘和内存中，并能控制数据的分区。同时，RDD还提供了一组丰富的操作来操作这些数据。在这些操作中，诸如map、flatMap、filter等转换操作实现了monad模式，很好地契合了Scala的集合操作。除此之外，RDD还提供了诸如join、groupBy、reduceByKey等更为方便的操作（注意，reduceByKey是action，而非transformation），以支持常见的数据运算。 RDD作为数据结构，本质上是一个只读的分区记录集合。一个RDD可以包含多个分区，每个分区就是一个dataset片段。RDD可以相互依赖。如果RDD的每个分区最多只能被一个Child RDD的一个分区使用，则称之为narrow dependency；若多个Child RDD分区都可以依赖，则称之为wide dependency。不同的操作依据其特性，可能会产生不同的依赖。例如map操作会产生narrow dependency，而join操作则产生wide dependency。</p>
</blockquote>
<h5 id="主要部分组成"><a href="#主要部分组成" class="headerlink" title="主要部分组成"></a>主要部分组成</h5><ol>
<li><code>partitions</code> — partition集合，一个RDD中有多少data partition</li>
<li><code>dependencies</code> — RDD依赖关系</li>
<li><code>compute(parition)</code>— 对于给定的数据集，需要作哪些计算</li>
<li><code>preferredLocations</code> — 对于data partition的位置偏好</li>
<li><code>partitioner</code> — 对于计算出来的数据结果如何分发</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码量&quot;&gt;&lt;a href=&quot;#代码量&quot; class=&quot;headerlink&quot; title=&quot;代码量&quot;&gt;&lt;/a&gt;代码量&lt;/h2&gt;&lt;p&gt;Spark: 20,000 LOC&lt;/p&gt;
&lt;p&gt;Hadoop 1.0: 90,000 LOC&lt;/p&gt;
&lt;p&gt;Hadoop 2.0: 220,000 LOC&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-mtunique.qbox.me/sparkCodeSize.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;&lt;code&gt;RDD&lt;/code&gt; - resillient distributed dataset 弹性分布式数据集&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Operation&lt;/code&gt; - 作用于RDD的各种操作分为transformation和action&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Job&lt;/code&gt; - 作业，一个JOB包含多个RDD及作用于相应RDD上的各种operation&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stage&lt;/code&gt; - 一个作业分为多个阶段&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Partition&lt;/code&gt; - 数据分区， 一个RDD中的数据可以分成多个不同的区&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DAG&lt;/code&gt; - Directed Acycle graph, 有向无环图，反应RDD之间的依赖关系&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Narrow dependency&lt;/code&gt; - 窄依赖，子RDD依赖于父RDD中固定的data partition&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Wide Dependency&lt;/code&gt; - 宽依赖，子RDD对父RDD中的所有data partition都有依赖&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Caching Managenment&lt;/code&gt; - 缓存管理，对RDD的中间计算结果进行缓存管理以加快整体的处理速度&lt;br&gt;
    
    </summary>
    
      <category term="big-data" scheme="http://mtunique.com/categories/big-data/"/>
    
      <category term="spark" scheme="http://mtunique.com/categories/big-data/spark/"/>
    
    
      <category term="big-data" scheme="http://mtunique.com/tags/big-data/"/>
    
      <category term="spark" scheme="http://mtunique.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>【Tornado笔记】tornado.web.Application</title>
    <link href="http://mtunique.com/tornado_application/"/>
    <id>http://mtunique.com/tornado_application/</id>
    <published>2014-11-28T05:30:00.000Z</published>
    <updated>2017-01-07T11:58:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>从tornado的 Hello,world 开始分析tornado的源码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tornado.ioloop</div><div class="line"><span class="keyword">import</span> tornado.web</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        self.write(<span class="string">"Hello, world"</span>)</div><div class="line"></div><div class="line">application = tornado.web.Application([</div><div class="line">    (<span class="string">r"/"</span>, MainHandler),</div><div class="line">])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    application.listen(<span class="number">8888</span>)</div><div class="line">    tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure>
<p>很容易可以看出，通过继承<code>RequestHandler</code>类定义自己的处理类，来处理请求。<code>Application</code>类的对象来处理URI的路由（将URI<code>r&quot;/&quot;</code>于处理类<code>MainHandler</code>组成tuple，关联起来）。</p>
<a id="more"></a>
<h3 id="tornado-web-Application类"><a href="#tornado-web-Application类" class="headerlink" title="tornado.web.Application类"></a>tornado.web.Application类</h3><h4 id="一、init"><a href="#一、init" class="headerlink" title="一、init"></a>一、init</h4><p>简化版代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers=None, default_host=<span class="string">""</span>, transforms=None,</span></span></div><div class="line">             **settings):</div><div class="line">    <span class="keyword">if</span> transforms <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        self.transforms = []</div><div class="line">        <span class="keyword">if</span> settings.get(<span class="string">"compress_response"</span>) <span class="keyword">or</span> settings.get(<span class="string">"gzip"</span>):</div><div class="line">            self.transforms.append(GZipContentEncoding)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        self.transforms = transforms</div><div class="line">    ......</div><div class="line">    self.ui_modules = &#123;<span class="string">'linkify'</span>: _linkify,</div><div class="line">                       <span class="string">'xsrf_form_html'</span>: _xsrf_form_html,</div><div class="line">                       <span class="string">'Template'</span>: TemplateModule,</div><div class="line">                       &#125;</div><div class="line">    self.ui_methods = &#123;&#125;</div><div class="line">    self._load_ui_modules(settings.get(<span class="string">"ui_modules"</span>, &#123;&#125;))</div><div class="line">    self._load_ui_methods(settings.get(<span class="string">"ui_methods"</span>, &#123;&#125;))</div><div class="line"></div><div class="line">    <span class="keyword">if</span> self.settings.get(<span class="string">"static_path"</span>):</div><div class="line">        ......</div><div class="line">    <span class="keyword">if</span> handlers:</div><div class="line">        self.add_handlers(<span class="string">".*$"</span>, handlers)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> self.settings.get(<span class="string">'debug'</span>):</div><div class="line">        self.settings.setdefault(<span class="string">'autoreload'</span>, <span class="keyword">True</span>)</div><div class="line">        ......</div><div class="line">    <span class="comment"># Automatically reload modified modules</span></div><div class="line">    <span class="keyword">if</span> self.settings.get(<span class="string">'autoreload'</span>):</div><div class="line">        <span class="keyword">from</span> tornado <span class="keyword">import</span> autoreload</div><div class="line">        autoreload.start()</div></pre></td></tr></table></figure>
<p>参数handlers是一个list，list里每个object是一个URLSpec的对象tuple。tuple可以是二到四个element，分别是URI的正则、handler类、用于初始化URLSpec的kwargs、handler的name。 （下面add_handlers详细说明）</p>
<p>参数settings是一个dict，所有settings的具体用法</p>
<ol>
<li><p>初始化transforms（HTTP传输压缩等，默认GZipContentEncoding 和 ChunkedTransferEncoding 。也可以自己实现，需要实现 transform_first_chunk 和 transform_chunk 接口，RequestHandler 中的 flush 调用，剖析RequestHandler时详细介绍），UI模块</p>
</li>
<li><p>通过settings的值来初始化静态文件处理Handler，包括：</p>
<ul>
<li>static_path</li>
<li>static_url_prefix</li>
<li>static_handler_class</li>
<li>static_handler_args</li>
<li>static_hash_cache</li>
</ul>
</li>
<li><p>初始化其他settings</p>
</li>
<li><p>调用add_handlers方法添加handlers。 5.加载自动重新加载模块（当检测到代码被修改后重构启动）</p>
</li>
</ol>
<h4 id="二、add-handle"><a href="#二、add-handle" class="headerlink" title="二、add_handle"></a>二、add_handle</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_handlers</span><span class="params">(self, host_pattern, host_handlers)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> host_pattern.endswith(<span class="string">"$"</span>):</div><div class="line">        host_pattern += <span class="string">"$"</span></div><div class="line">    handlers = []</div><div class="line">    <span class="keyword">if</span> self.handlers <span class="keyword">and</span> self.handlers[<span class="number">-1</span>][<span class="number">0</span>].pattern == <span class="string">'.*$'</span>:</div><div class="line">        self.handlers.insert(<span class="number">-1</span>, (re.compile(host_pattern), handlers))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        self.handlers.append((re.compile(host_pattern), handlers))</div><div class="line"></div><div class="line">    <span class="keyword">for</span> spec <span class="keyword">in</span> host_handlers:</div><div class="line">        <span class="keyword">if</span> isinstance(spec, (tuple, list)):</div><div class="line">            <span class="keyword">assert</span> len(spec) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line">            spec = URLSpec(*spec)</div><div class="line">        handlers.append(spec)</div><div class="line">        <span class="keyword">if</span> spec.name:</div><div class="line">            <span class="keyword">if</span> spec.name <span class="keyword">in</span> self.named_handlers:</div><div class="line">                app_log.warning(</div><div class="line">                    <span class="string">"Multiple handlers named %s; replacing previous value"</span>,</div><div class="line">                    spec.name)</div><div class="line">            self.named_handlers[spec.name] = spec</div></pre></td></tr></table></figure>
<p>将<code>host_pattern</code>和<code>handlers</code>，组成tuple加到<code>self.handlers</code>的末尾但是在匹配所有域名的tuple前。</p>
<p>由<code>spec = URLSpec(*spec)</code>易看出初始化Application的时候的第一个参数存的tuple是用来初始化URLSpec的所以参数顺序应该和URLSpec要求的一样（<code>def __init__(self, pattern, handler, kwargs=None, name=None)</code>）。</p>
<p>用过第四个参数name来构造反响代理，储存在<code>Application</code>的<code>named_handlers</code>（dict）里。</p>
<p>hello world里调用了<code>Application.listen</code>和<code>tornado.ioloop.IOLoop.instance().start()</code>（以后会详细介绍<code>IOLoop</code>），来真正启动。</p>
<h4 id="三、listen"><a href="#三、listen" class="headerlink" title="三、listen"></a>三、listen</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, port, address=<span class="string">""</span>, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">from</span> tornado.httpserver <span class="keyword">import</span> HTTPServer</div><div class="line">        server = HTTPServer(self, **kwargs)</div><div class="line">        server.listen(port, address)</div></pre></td></tr></table></figure>
<p>实例化一个<code>HTTPServer</code>，将<code>Application</code>绑定上去。</p>
<p>当有请求的时候<code>HTTPServer</code>将会调用<code>Application.start_request</code>来将<code>application</code>和<code>connection</code>绑定在一起初始化一个<code>_RequestDispatcher</code>的对象，由其来处理请求的路由，从而利用已经通过<code>add_handler</code>建立的路由规则。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从tornado的 Hello,world 开始分析tornado的源码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tornado.ioloop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tornado.web&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(tornado.web.RequestHandler)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.write(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;application = tornado.web.Application([&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    (&lt;span class=&quot;string&quot;&gt;r&quot;/&quot;&lt;/span&gt;, MainHandler),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    application.listen(&lt;span class=&quot;number&quot;&gt;8888&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    tornado.ioloop.IOLoop.instance().start()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;很容易可以看出，通过继承&lt;code&gt;RequestHandler&lt;/code&gt;类定义自己的处理类，来处理请求。&lt;code&gt;Application&lt;/code&gt;类的对象来处理URI的路由（将URI&lt;code&gt;r&amp;quot;/&amp;quot;&lt;/code&gt;于处理类&lt;code&gt;MainHandler&lt;/code&gt;组成tuple，关联起来）。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://mtunique.com/categories/python/"/>
    
    
      <category term="python" scheme="http://mtunique.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【Tornado笔记】tornado.web.IOLoop和tornado.util.Configurable</title>
    <link href="http://mtunique.com/tornado_ioloop/"/>
    <id>http://mtunique.com/tornado_ioloop/</id>
    <published>2014-11-28T05:30:00.000Z</published>
    <updated>2017-01-07T11:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.mtunique.com/tornado_application.html" target="_blank" rel="external">上一篇文章</a>tornado的 Hello,<br>world 还没有分析完 还差最后一句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tornado.ioloop</div><div class="line"><span class="keyword">import</span> tornado.web</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        self.write(<span class="string">"Hello, world"</span>)</div><div class="line"></div><div class="line">application = tornado.web.Application([</div><div class="line">    (<span class="string">r"/"</span>, MainHandler),</div><div class="line">])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    application.listen(<span class="number">8888</span>)</div><div class="line">    tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure>
<p>IOLoop就是整个tornado区别于其他框架的最关键的地方。</p>
<a id="more"></a>
<h4 id="一、tornado-ioloop-IOLoop-instance"><a href="#一、tornado-ioloop-IOLoop-instance" class="headerlink" title="一、tornado.ioloop.IOLoop.instance"></a>一、<code>tornado.ioloop.IOLoop.instance</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@staticmethod</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(IOLoop, <span class="string">"_instance"</span>):</div><div class="line">        <span class="keyword">with</span> IOLoop._instance_lock:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> hasattr(IOLoop, <span class="string">"_instance"</span>):</div><div class="line">                <span class="comment"># New instance after double check</span></div><div class="line">                IOLoop._instance = IOLoop()</div><div class="line">    <span class="keyword">return</span> IOLoop._instance</div></pre></td></tr></table></figure>
<p>每个tornado进程都会有一个全局的<code>IOLoop</code>实例，这个方法就是用来获得这个实例的。</p>
<p><code>with IOLoop._instance_lock</code>保证了创建的这个实例的过程是线程安全的。</p>
<p><code>IOLoop</code>继承了<code>tornado.util.Configurable</code>。<code>Configurable</code><br>（是一个“抽象”类）实现了<code>__new__</code>，所以将自动调用了<code>__new__</code>生成<code>IOLoop</code>的实例。</p>
<h4 id="二、tornado-util-Configurable-new"><a href="#二、tornado-util-Configurable-new" class="headerlink" title="二、tornado.util.Configurable.__new__()"></a>二、<code>tornado.util.Configurable.__new__()</code></h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def __new__(cls, **kwargs):</div><div class="line">    base = cls.configurable_base()</div><div class="line">    args = &#123;&#125;</div><div class="line">    if cls is base:</div><div class="line">        impl = cls.configured_class()</div><div class="line">        if base.__impl_kwargs:</div><div class="line">            args.update(base.__impl_kwargs)</div><div class="line">    else:</div><div class="line">        impl = cls</div><div class="line">    args.update(kwargs)</div><div class="line">    instance = super(Configurable, cls).__new__(impl)</div><div class="line">    # initialize vs __init__ chosen for compatibility with AsyncHTTPClient</div><div class="line">    # singleton magic.  If we get rid of that we can switch to __init__</div><div class="line">    # here too.</div><div class="line">    instance.initialize(**args)</div><div class="line">    return instance&lt;/pre&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.mtunique.com/tornado_application.html&quot;&gt;上一篇文章&lt;/a&gt;tornado的 Hello,&lt;br&gt;world 还没有分析完 还差最后一句&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tornado.ioloop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tornado.web&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(tornado.web.RequestHandler)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.write(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;application = tornado.web.Application([&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    (&lt;span class=&quot;string&quot;&gt;r&quot;/&quot;&lt;/span&gt;, MainHandler),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    application.listen(&lt;span class=&quot;number&quot;&gt;8888&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    tornado.ioloop.IOLoop.instance().start()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;IOLoop就是整个tornado区别于其他框架的最关键的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://mtunique.com/categories/python/"/>
    
    
      <category term="python" scheme="http://mtunique.com/tags/python/"/>
    
  </entry>
  
</feed>
