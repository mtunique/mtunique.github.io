<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on mtunique blog</title><link>https://mtunique.com/categories/python/</link><description>Recent content in python on mtunique blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>mtunique</copyright><lastBuildDate>Sat, 24 Jan 2015 14:30:00 +0800</lastBuildDate><atom:link href="https://mtunique.com/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>另一个Lambda表达式教程</title><link>https://mtunique.com/posts/lambda_python/</link><pubDate>Sat, 24 Jan 2015 14:30:00 +0800</pubDate><guid>https://mtunique.com/posts/lambda_python/</guid><description>有很多Python的lambda教程[1]。最近我偶然发现一个，真挺有用的。是Mike Driscoll在Mouse VS Python 博客上的关于lambda的讨论) 。
当我刚开始学习Python，最容易困惑的概念之一，是lambda语句。我敢肯定， 其他新的程序员也对它很困惑... Mike的讨论非常好：清晰，直接，且含有实用的示例。它帮助我终于领会了lambda，并导致我写的另一篇lambda教程。
一个用来构造函数的工具 基本上，Python的lambda是用于构造函数（或更精确地说，函数对象）的工具。这意味着，Python有两个构造函数的工具：def和lambda。
下面是一个例子。您可以以正常的方式用def构造一个函数，就像这样：
def square_root(x): return math.sqrt(x) 或者你可以用lambda
square_root = lambda x: math.sqrt(x) 下面是lambda的其他的一些有趣的例子：
sum = lambda x, y: x + y # def sum(x,y): return x + y out = lambda *x: sys.stdout.write(&amp;#34; &amp;#34;.join(map(str,x))) lambda event, name=button8.getLabel(): self.onButton(event, name) lambda的好处在哪里？ 已经困扰我有很长一段时间的一个问题是：lambda的好处在哪里？为什么我们需要lambda？
答案是： 我们并不需要lambda，我们不用它一样可以做所有的事情。但是… 在特定的情况下，很是方便 - 它让编写代码更容易一些，而且编写的代码更整洁。
什么样的情况？ 好，其中一个情况是，我们需要一个简单的一次性功能：将被只使用一次函数。
通常，写函数有两个目的：(a)以减少代码重复（b）模块化代码。
如果你的应用程序在不同的地方包含重复的代码块，那么你就可以把代码拷贝到一个函数，给函数名，然后 – 使用该函数名 - 在代码中的不同位置调用它。 如果你有一个代码块执行一个明确的操作 - 但真的是冗长、粗糙、破坏程序的可读性，那么你可以把那么长的粗糙的所有代码变成一个函数。 但是，假设你需要创建一个函数，将只被使用一次 - 只从应用程序中的一个地方调用。好吧，首先，你不需要给函数的名称。它可以是“匿名的”。而且你可以把它定义在你想使用它的地方。这就是lambda是非常有用的时候。</description></item><item><title>【Tornado笔记】tornado.web.Application</title><link>https://mtunique.com/posts/tornado_application/</link><pubDate>Fri, 28 Nov 2014 13:30:27 +0800</pubDate><guid>https://mtunique.com/posts/tornado_application/</guid><description>从tornado的 Hello,world 开始分析tornado的源码
import tornado.ioloop import tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.write(&amp;#34;Hello, world&amp;#34;) application = tornado.web.Application([ (r&amp;#34;/&amp;#34;, MainHandler), ]) if __name__ == &amp;#34;__main__&amp;#34;: application.listen(8888) tornado.ioloop.IOLoop.instance().start() 很容易可以看出，通过继承RequestHandler类定义自己的处理类，来处理请求。Application类的对象来处理URI的路由（将URIr&amp;quot;/&amp;quot;于处理类MainHandler组成tuple，关联起来）。
tornado.web.Application类 一、init 简化版代码：
def __init__(self, handlers=None, default_host=&amp;#34;&amp;#34;, transforms=None, **settings): if transforms is None: self.transforms = [] if settings.get(&amp;#34;compress_response&amp;#34;) or settings.get(&amp;#34;gzip&amp;#34;): self.transforms.append(GZipContentEncoding) else: self.transforms = transforms ...... self.ui_modules = {&amp;#39;linkify&amp;#39;: _linkify, &amp;#39;xsrf_form_html&amp;#39;: _xsrf_form_html, &amp;#39;Template&amp;#39;: TemplateModule, } self.ui_methods = {} self._load_ui_modules(settings.get(&amp;#34;ui_modules&amp;#34;, {})) self._load_ui_methods(settings.get(&amp;#34;ui_methods&amp;#34;, {})) if self.settings.get(&amp;#34;static_path&amp;#34;): .</description></item><item><title>【Tornado笔记】tornado.web.IOLoop和tornado.util.Configurable</title><link>https://mtunique.com/posts/tornado_ioloop/</link><pubDate>Fri, 28 Nov 2014 13:30:27 +0800</pubDate><guid>https://mtunique.com/posts/tornado_ioloop/</guid><description>上一篇文章tornado的 Hello, world 还没有分析完 还差最后一句
import tornado.ioloop import tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.write(&amp;#34;Hello, world&amp;#34;) application = tornado.web.Application([ (r&amp;#34;/&amp;#34;, MainHandler), ]) if __name__ == &amp;#34;__main__&amp;#34;: application.listen(8888) tornado.ioloop.IOLoop.instance().start() IOLoop就是整个tornado区别于其他框架的最关键的地方。
一、tornado.ioloop.IOLoop.instance @staticmethod def instance(): if not hasattr(IOLoop, &amp;#34;_instance&amp;#34;): with IOLoop._instance_lock: if not hasattr(IOLoop, &amp;#34;_instance&amp;#34;): # New instance after double check IOLoop._instance = IOLoop() return IOLoop._instance 每个tornado进程都会有一个全局的IOLoop实例，这个方法就是用来获得这个实例的。
with IOLoop._instance_lock保证了创建的这个实例的过程是线程安全的。
IOLoop继承了tornado.util.Configurable。Configurable （是一个“抽象”类）实现了__new__，所以将自动调用了__new__生成IOLoop的实例。
二、tornado.util.Configurable.__new__() def __new__(cls, **kwargs): base = cls.configurable_base() args = {} if cls is base: impl = cls.</description></item></channel></rss>